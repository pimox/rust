Index: zstd-sys-1/Cargo.toml
===================================================================
--- zstd-sys-1.orig/Cargo.toml
+++ zstd-sys-1/Cargo.toml
@@ -26,18 +26,9 @@ repository = "https://github.com/gyscos/
 version = "0.2.45"
 [build-dependencies.bindgen]
 version = "0.47.0"
-optional = true
-
-[build-dependencies.cc]
-version = "1.0.28"
-features = ["parallel"]
-
-[build-dependencies.glob]
-version = "0.2.11"
 
 [build-dependencies.pkg-config]
 version = "0.3"
-optional = true
 
 [features]
 default = ["legacy"]
Index: zstd-sys-1/build.rs
===================================================================
--- zstd-sys-1.orig/build.rs
+++ zstd-sys-1/build.rs
@@ -1,16 +1,10 @@
-#[cfg(feature = "bindgen")]
 extern crate bindgen;
 
-#[cfg(feature = "pkg-config")]
 extern crate pkg_config;
 
-extern crate cc;
-extern crate glob;
-
 use std::path::PathBuf;
 use std::{env, fs};
 
-#[cfg(feature = "bindgen")]
 fn generate_bindings(defs: Vec<&str>, headerpaths: Vec<PathBuf>) {
     use std::env;
     use std::path::PathBuf;
@@ -41,10 +35,6 @@ fn generate_bindings(defs: Vec<&str>, he
         .expect("Could not write bindings");
 }
 
-#[cfg(not(feature = "bindgen"))]
-fn generate_bindings(_: Vec<&str>, _: Vec<PathBuf>) {}
-
-#[cfg(feature = "pkg-config")]
 fn pkg_config() -> (Vec<&'static str>, Vec<PathBuf>) {
     let library = pkg_config::Config::new()
         .statik(true)
@@ -54,98 +44,10 @@ fn pkg_config() -> (Vec<&'static str>, V
     (vec!["PKG_CONFIG"], library.include_paths)
 }
 
-#[cfg(not(feature = "pkg-config"))]
-fn pkg_config() -> (Vec<&'static str>, Vec<PathBuf>) {
-    unimplemented!()
-}
-
-#[cfg(not(feature = "legacy"))]
-fn set_legacy(_config: &mut cc::Build) {}
-
-#[cfg(feature = "legacy")]
-fn set_legacy(config: &mut cc::Build) {
-    config.define("ZSTD_LEGACY_SUPPORT", Some("1"));
-}
-
-#[cfg(feature = "zstdmt")]
-fn set_pthread(config: &mut cc::Build) {
-    config.flag("-pthread");
-}
-
-#[cfg(not(feature = "zstdmt"))]
-fn set_pthread(_config: &mut cc::Build) {}
-
-fn compile_zstd() {
-    let mut config = cc::Build::new();
-
-    let globs = &[
-        "zstd/lib/common/*.c",
-        "zstd/lib/compress/*.c",
-        "zstd/lib/decompress/*.c",
-        "zstd/lib/legacy/*.c",
-        "zstd/lib/dictBuilder/*.c",
-    ];
-
-    for pattern in globs {
-        for path in glob::glob(pattern).unwrap() {
-            let path = path.unwrap();
-            config.file(path);
-        }
-    }
-
-    // Some extra parameters
-    config.opt_level(3);
-    config.include("zstd/lib/");
-    config.include("zstd/lib/common");
-    config.include("zstd/lib/legacy");
-    config.warnings(false);
-
-    config.define("ZSTD_LIB_DEPRECATED", Some("0"));
-
-    // Hide symbols from resulting library,
-    // so we can be used with another zstd-linking lib.
-    // See https://github.com/gyscos/zstd-rs/issues/58
-    config.flag("-fvisibility=hidden");
-    config.define("ZSTDLIB_VISIBILITY", Some(""));
-    config.define("ZDICTLIB_VISIBILITY", Some(""));
-    config.define("ZSTDERRORLIB_VISIBILITY", Some(""));
-
-    set_pthread(&mut config);
-    set_legacy(&mut config);
-
-    // Compile!
-    config.compile("libzstd.a");
-
-    let src = env::current_dir().unwrap().join("zstd").join("lib");
-    let dst = PathBuf::from(env::var_os("OUT_DIR").unwrap());
-    let include = dst.join("include");
-    fs::create_dir_all(&include).unwrap();
-    fs::copy(src.join("zstd.h"), include.join("zstd.h")).unwrap();
-    fs::copy(
-        src.join("dictBuilder").join("zdict.h"),
-        include.join("zdict.h"),
-    )
-    .unwrap();
-    println!("cargo:root={}", dst.display());
-}
-
 fn main() {
     // println!("cargo:rustc-link-lib=zstd");
 
-    if !PathBuf::from("zstd/lib").exists() {
-        panic!("Folder 'zstd/lib' does not exists. Maybe you forget clone 'zstd' submodule?");
-    }
-
-    let (defs, headerpaths) = if cfg!(feature = "pkg-config") {
-        pkg_config()
-    } else {
-        if !PathBuf::from("zstd/lib").exists() {
-            panic!("Folder 'zstd/lib' does not exists. Maybe you forget clone 'zstd' submodule?");
-        }
-
-        compile_zstd();
-        (vec![], vec![PathBuf::from("zstd/lib")])
-    };
+    let (defs, headerpaths) = pkg_config();
 
     generate_bindings(defs, headerpaths);
 }
Index: zstd-sys-1/src/bindings.rs
===================================================================
--- zstd-sys-1.orig/src/bindings.rs
+++ /dev/null
@@ -1,941 +0,0 @@
-/* automatically generated by rust-bindgen */
-
-pub const ZSTD_VERSION_MAJOR: u32 = 1;
-pub const ZSTD_VERSION_MINOR: u32 = 4;
-pub const ZSTD_VERSION_RELEASE: u32 = 0;
-pub const ZSTD_VERSION_NUMBER: u32 = 10400;
-pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
-pub const ZSTD_MAGICNUMBER: u32 = 4247762216;
-pub const ZSTD_MAGIC_DICTIONARY: u32 = 3962610743;
-pub const ZSTD_MAGIC_SKIPPABLE_START: u32 = 407710288;
-pub const ZSTD_MAGIC_SKIPPABLE_MASK: u32 = 4294967280;
-pub const ZSTD_BLOCKSIZELOG_MAX: u32 = 17;
-pub const ZSTD_BLOCKSIZE_MAX: u32 = 131072;
-pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
-pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
-pub type wchar_t = ::libc::c_int;
-extern "C" {
-    pub fn ZSTD_versionNumber() -> ::libc::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_versionString() -> *const ::libc::c_char;
-}
-extern "C" {
-    #[doc = "  Simple API"]
-    #[doc = "  Compresses `src` content as a single zstd compressed frame into already allocated `dst`."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = "  @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "            or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress(
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-        compressionLevel: ::libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress() :"]
-    #[doc = "  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames."]
-    #[doc = "  `dstCapacity` is an upper bound of originalSize to regenerate."]
-    #[doc = "  If user cannot imply a maximum upper bound, it\'s better to use streaming mode to decompress data."]
-    #[doc = "  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),"]
-    #[doc = "            or an errorCode if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_decompress(
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        compressedSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_getFrameContentSize(
-        src: *const ::libc::c_void,
-        srcSize: usize,
-    ) -> ::libc::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_getDecompressedSize() :"]
-    #[doc = "  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize()."]
-    #[doc = "  Both functions work the same way, but ZSTD_getDecompressedSize() blends"]
-    #[doc = "  \"empty\", \"unknown\" and \"error\" results to the same return value (0),"]
-    #[doc = "  while ZSTD_getFrameContentSize() gives them separate return values."]
-    #[doc = " @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."]
-    pub fn ZSTD_getDecompressedSize(
-        src: *const ::libc::c_void,
-        srcSize: usize,
-    ) -> ::libc::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_findFrameCompressedSize() :"]
-    #[doc = " `src` should point to the start of a ZSTD frame or skippable frame."]
-    #[doc = " `srcSize` must be >= first frame size"]
-    #[doc = " @return : the compressed size of the first frame starting at `src`,"]
-    #[doc = "           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,"]
-    #[doc = "        or an error code if input is invalid"]
-    pub fn ZSTD_findFrameCompressedSize(
-        src: *const ::libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_isError(code: usize) -> ::libc::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_getErrorName(code: usize) -> *const ::libc::c_char;
-}
-extern "C" {
-    pub fn ZSTD_minCLevel() -> ::libc::c_int;
-}
-extern "C" {
-    pub fn ZSTD_maxCLevel() -> ::libc::c_int;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CCtx_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Explicit context"]
-pub type ZSTD_CCtx = ZSTD_CCtx_s;
-extern "C" {
-    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compressCCtx() :"]
-    #[doc = "  Same as ZSTD_compress(), using an explicit ZSTD_CCtx"]
-    #[doc = "  The function will compress at requested compression level,"]
-    #[doc = "  ignoring any other parameter"]
-    pub fn ZSTD_compressCCtx(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-        compressionLevel: ::libc::c_int,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DCtx_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DCtx = ZSTD_DCtx_s;
-extern "C" {
-    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressDCtx() :"]
-    #[doc = "  Same as ZSTD_decompress(),"]
-    #[doc = "  requires an allocated ZSTD_DCtx."]
-    #[doc = "  Compatible with sticky parameters."]
-    pub fn ZSTD_decompressDCtx(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced compression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_strategy {
-    ZSTD_fast = 1,
-    ZSTD_dfast = 2,
-    ZSTD_greedy = 3,
-    ZSTD_lazy = 4,
-    ZSTD_lazy2 = 5,
-    ZSTD_btlazy2 = 6,
-    ZSTD_btopt = 7,
-    ZSTD_btultra = 8,
-    ZSTD_btultra2 = 9,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_cParameter {
-    ZSTD_c_compressionLevel = 100,
-    ZSTD_c_windowLog = 101,
-    ZSTD_c_hashLog = 102,
-    ZSTD_c_chainLog = 103,
-    ZSTD_c_searchLog = 104,
-    ZSTD_c_minMatch = 105,
-    ZSTD_c_targetLength = 106,
-    ZSTD_c_strategy = 107,
-    ZSTD_c_enableLongDistanceMatching = 160,
-    ZSTD_c_ldmHashLog = 161,
-    ZSTD_c_ldmMinMatch = 162,
-    ZSTD_c_ldmBucketSizeLog = 163,
-    ZSTD_c_ldmHashRateLog = 164,
-    ZSTD_c_contentSizeFlag = 200,
-    ZSTD_c_checksumFlag = 201,
-    ZSTD_c_dictIDFlag = 202,
-    ZSTD_c_nbWorkers = 400,
-    ZSTD_c_jobSize = 401,
-    ZSTD_c_overlapLog = 402,
-    ZSTD_c_experimentalParam1 = 500,
-    ZSTD_c_experimentalParam2 = 10,
-    ZSTD_c_experimentalParam3 = 1000,
-    ZSTD_c_experimentalParam4 = 1001,
-    ZSTD_c_experimentalParam5 = 1002,
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_bounds {
-    pub error: usize,
-    pub lowerBound: ::libc::c_int,
-    pub upperBound: ::libc::c_int,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_bounds() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_bounds>(),
-        16usize,
-        concat!("Size of: ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_bounds>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).error as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(error)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).lowerBound as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(lowerBound)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).upperBound as *const _
-                as usize
-        },
-        12usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(upperBound)
-        )
-    );
-}
-extern "C" {
-    #[doc = " ZSTD_cParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - lower and upper bounds, both inclusive"]
-    pub fn ZSTD_cParam_getBounds(cParam: ZSTD_cParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is generally only possible during frame initialization (before starting compression)."]
-    #[doc = "  Exception : when using multi-threading mode (nbWorkers >= 1),"]
-    #[doc = "              the following parameters can be updated _during_ compression (within same frame):"]
-    #[doc = "              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy."]
-    #[doc = "              new parameters will be active for next job only (after a flush())."]
-    #[doc = " @return : an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_CCtx_setParameter(
-        cctx: *mut ZSTD_CCtx,
-        param: ZSTD_cParameter,
-        value: ::libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setPledgedSrcSize() :"]
-    #[doc = "  Total input data size to be compressed as a single frame."]
-    #[doc = "  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag."]
-    #[doc = "  This value will also be controlled at end of frame, and trigger an error if not respected."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame."]
-    #[doc = "           In order to mean \"unknown content size\", pass constant ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame."]
-    #[doc = "  Note 2 : pledgedSrcSize is only valid once, for the next frame."]
-    #[doc = "           It\'s discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "  Note 3 : Whenever all input data is provided and consumed in a single round,"]
-    #[doc = "           for example with ZSTD_compress2(),"]
-    #[doc = "           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),"]
-    #[doc = "           this value is automatically overridden by srcSize instead."]
-    pub fn ZSTD_CCtx_setPledgedSrcSize(
-        cctx: *mut ZSTD_CCtx,
-        pledgedSrcSize: ::libc::c_ulonglong,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_ResetDirective {
-    ZSTD_reset_session_only = 1,
-    ZSTD_reset_parameters = 2,
-    ZSTD_reset_session_and_parameters = 3,
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_reset() :"]
-    #[doc = "  There are 2 different things that can be reset, independently or jointly :"]
-    #[doc = "  - The session : will stop compressing current frame, and make CCtx ready to start a new one."]
-    #[doc = "                  Useful after an error, or to interrupt any ongoing compression."]
-    #[doc = "                  Any internal data not yet flushed is cancelled."]
-    #[doc = "                  Compression parameters and dictionary remain unchanged."]
-    #[doc = "                  They will be used to compress next frame."]
-    #[doc = "                  Resetting session never fails."]
-    #[doc = "  - The parameters : changes all parameters back to \"default\"."]
-    #[doc = "                  This removes any reference to any dictionary too."]
-    #[doc = "                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)"]
-    #[doc = "                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())"]
-    #[doc = "  - Both : similar to resetting the session, followed by resetting parameters."]
-    pub fn ZSTD_CCtx_reset(
-        cctx: *mut ZSTD_CCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress2() :"]
-    #[doc = "  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API."]
-    #[doc = "  ZSTD_compress2() always starts a new frame."]
-    #[doc = "  Should cctx hold data from a previously unfinished frame, everything about it is forgotten."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - The function is always blocking, returns when compression is completed."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = " @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "           or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress2(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced decompression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dParameter {
-    ZSTD_d_windowLogMax = 100,
-    ZSTD_d_experimentalParam1 = 1000,
-}
-extern "C" {
-    #[doc = " ZSTD_dParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - both lower and upper bounds, inclusive"]
-    pub fn ZSTD_dParam_getBounds(dParam: ZSTD_dParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_dParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is only possible during frame initialization (before starting decompression)."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setParameter(
-        dctx: *mut ZSTD_DCtx,
-        param: ZSTD_dParameter,
-        value: ::libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_reset() :"]
-    #[doc = "  Return a DCtx to clean state."]
-    #[doc = "  Session and parameters can be reset jointly or separately."]
-    #[doc = "  Parameters can only be reset when no active frame is being decompressed."]
-    #[doc = " @return : 0, or an error code, which can be tested with ZSTD_isError()"]
-    pub fn ZSTD_DCtx_reset(
-        dctx: *mut ZSTD_DCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-#[doc = "  Streaming"]
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_inBuffer_s {
-    #[doc = "< start of input buffer"]
-    pub src: *const ::libc::c_void,
-    #[doc = "< size of input buffer"]
-    pub size: usize,
-    #[doc = "< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_inBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_inBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_inBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).src as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(src)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_outBuffer_s {
-    #[doc = "< start of output buffer"]
-    pub dst: *mut ::libc::c_void,
-    #[doc = "< size of output buffer"]
-    pub size: usize,
-    #[doc = "< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_outBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_outBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_outBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).dst as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(dst)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
-pub type ZSTD_CStream = ZSTD_CCtx;
-extern "C" {
-    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_EndDirective {
-    ZSTD_e_continue = 0,
-    ZSTD_e_flush = 1,
-    ZSTD_e_end = 2,
-}
-extern "C" {
-    #[doc = " ZSTD_compressStream2() :"]
-    #[doc = "  Behaves about the same as ZSTD_compressStream, with additional control on end directive."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)"]
-    #[doc = "  - output->pos must be <= dstCapacity, input->pos must be <= srcSize"]
-    #[doc = "  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit."]
-    #[doc = "  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller."]
-    #[doc = "  - When nbWorkers>=1, function is non-blocking : it just acquires a copy of input, and distributes jobs to internal worker threads, flush whatever is available,"]
-    #[doc = "                                                  and then immediately returns, just indicating that there is some data remaining to be flushed."]
-    #[doc = "                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte."]
-    #[doc = "  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking."]
-    #[doc = "  - @return provides a minimum amount of data remaining to be flushed from internal buffers"]
-    #[doc = "            or an error code, which can be tested using ZSTD_isError()."]
-    #[doc = "            if @return != 0, flush is not fully completed, there is still some data left within internal buffers."]
-    #[doc = "            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers."]
-    #[doc = "            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed."]
-    #[doc = "  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),"]
-    #[doc = "            only ZSTD_e_end or ZSTD_e_flush operations are allowed."]
-    #[doc = "            Before starting a new compression job, or changing compression parameters,"]
-    #[doc = "            it is required to fully flush internal buffers."]
-    pub fn ZSTD_compressStream2(
-        cctx: *mut ZSTD_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    pub fn ZSTD_initCStream(
-        zcs: *mut ZSTD_CStream,
-        compressionLevel: ::libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue)."]
-    #[doc = " NOTE: The return value is different. ZSTD_compressStream() returns a hint for"]
-    #[doc = " the next read size (if non-zero and not an error). ZSTD_compressStream2()"]
-    #[doc = " returns the number of bytes left to flush (if non-zero and not an error)."]
-    pub fn ZSTD_compressStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush)."]
-    pub fn ZSTD_flushStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end)."]
-    pub fn ZSTD_endStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-pub type ZSTD_DStream = ZSTD_DCtx;
-extern "C" {
-    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressStream(
-        zds: *mut ZSTD_DStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = "  Simple dictionary API"]
-    #[doc = "  Compression at an explicit compression level using a Dictionary."]
-    #[doc = "  A dictionary can be any arbitrary data segment (also called a prefix),"]
-    #[doc = "  or a buffer with specified information (see dictBuilder/zdict.h)."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_compress_usingDict(
-        ctx: *mut ZSTD_CCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-        dict: *const ::libc::c_void,
-        dictSize: usize,
-        compressionLevel: ::libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDict() :"]
-    #[doc = "  Decompression using a known Dictionary."]
-    #[doc = "  Dictionary must be identical to the one used during compression."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_decompress_usingDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-        dict: *const ::libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CDict_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Bulk processing dictionary API"]
-pub type ZSTD_CDict = ZSTD_CDict_s;
-extern "C" {
-    #[doc = " ZSTD_createCDict() :"]
-    #[doc = "  When compressing multiple messages / blocks using the same dictionary, it\'s recommended to load it only once."]
-    #[doc = "  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup cost."]
-    #[doc = "  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only."]
-    #[doc = " `dictBuffer` can be released after ZSTD_CDict creation, because its content is copied within CDict."]
-    #[doc = "  Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate `dictBuffer` content."]
-    #[doc = "  Note : A ZSTD_CDict can be created from an empty dictBuffer, but it is inefficient when used to compress small data."]
-    pub fn ZSTD_createCDict(
-        dictBuffer: *const ::libc::c_void,
-        dictSize: usize,
-        compressionLevel: ::libc::c_int,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeCDict() :"]
-    #[doc = "  Function frees memory allocated by ZSTD_createCDict()."]
-    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_usingCDict() :"]
-    #[doc = "  Compression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    #[doc = "  Note : compression level is _decided at dictionary creation time_,"]
-    #[doc = "     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"]
-    pub fn ZSTD_compress_usingCDict(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DDict_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DDict = ZSTD_DDict_s;
-extern "C" {
-    #[doc = " ZSTD_createDDict() :"]
-    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
-    #[doc = "  dictBuffer can be released after DDict creation, as its content is copied inside DDict."]
-    pub fn ZSTD_createDDict(
-        dictBuffer: *const ::libc::c_void,
-        dictSize: usize,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeDDict() :"]
-    #[doc = "  Function frees memory allocated with ZSTD_createDDict()"]
-    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDDict() :"]
-    #[doc = "  Decompression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    pub fn ZSTD_decompress_usingDDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::libc::c_void,
-        dstCapacity: usize,
-        src: *const ::libc::c_void,
-        srcSize: usize,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDict() :"]
-    #[doc = "  Provides the dictID stored within dictionary."]
-    #[doc = "  if @return == 0, the dictionary is not conformant with Zstandard specification."]
-    #[doc = "  It can still be loaded, but as a content-only dictionary."]
-    pub fn ZSTD_getDictID_fromDict(
-        dict: *const ::libc::c_void,
-        dictSize: usize,
-    ) -> ::libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDDict() :"]
-    #[doc = "  Provides the dictID of the dictionary loaded into `ddict`."]
-    #[doc = "  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty."]
-    #[doc = "  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."]
-    pub fn ZSTD_getDictID_fromDDict(
-        ddict: *const ZSTD_DDict,
-    ) -> ::libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromFrame() :"]
-    #[doc = "  Provides the dictID required to decompressed the frame stored within `src`."]
-    #[doc = "  If @return == 0, the dictID could not be decoded."]
-    #[doc = "  This could for one of the following reasons :"]
-    #[doc = "  - The frame does not require a dictionary to be decoded (most common case)."]
-    #[doc = "  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information."]
-    #[doc = "    Note : this use case also happens when using a non-conformant dictionary."]
-    #[doc = "  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`)."]
-    #[doc = "  - This is not a Zstandard frame."]
-    #[doc = "  When identifying the exact failure cause, it\'s possible to use ZSTD_getFrameHeader(), which will provide a more precise error code."]
-    pub fn ZSTD_getDictID_fromFrame(
-        src: *const ::libc::c_void,
-        srcSize: usize,
-    ) -> ::libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary() :"]
-    #[doc = "  Create an internal CDict from `dict` buffer."]
-    #[doc = "  Decompression will have to use same dictionary."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,"]
-    #[doc = "           meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Dictionary is sticky, it will be used for all future compressed frames."]
-    #[doc = "           To return to \"no-dictionary\" situation, load a NULL dictionary (or reset parameters)."]
-    #[doc = "  Note 2 : Loading a dictionary involves building tables."]
-    #[doc = "           It\'s also a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           Tables are dependent on compression parameters, and for this reason,"]
-    #[doc = "           compression parameters can no longer be changed after loading a dictionary."]
-    #[doc = "  Note 3 :`dict` content will be copied internally."]
-    #[doc = "           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead."]
-    #[doc = "           In such a case, dictionary buffer must outlive its users."]
-    #[doc = "  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()"]
-    #[doc = "           to precisely select how dictionary content must be interpreted."]
-    pub fn ZSTD_CCtx_loadDictionary(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refCDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used for all next compressed frames."]
-    #[doc = "  Note that compression parameters are enforced from within CDict,"]
-    #[doc = "  and supersede any compression parameter previously set within CCtx."]
-    #[doc = "  The parameters ignored are labled as \"superseded-by-cdict\" in the ZSTD_cParameter enum docs."]
-    #[doc = "  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode."]
-    #[doc = "  The dictionary will remain valid for future compressed frames using same CCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Referencing a NULL CDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx."]
-    pub fn ZSTD_CCtx_refCDict(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) for next compressed frame."]
-    #[doc = "  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end)."]
-    #[doc = "  Decompression will need same prefix to properly regenerate data."]
-    #[doc = "  Compressing with a prefix is similar in outcome as performing a diff and compressing it,"]
-    #[doc = "  but performs much faster, especially during decompression (compression speed is tunable with compression level)."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary"]
-    #[doc = "  Note 1 : Prefix buffer is referenced. It **must** outlive compression."]
-    #[doc = "           Its content must remain unmodified during compression."]
-    #[doc = "  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,"]
-    #[doc = "           ensure that the window size is large enough to contain the entire source."]
-    #[doc = "           See ZSTD_c_windowLog."]
-    #[doc = "  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters."]
-    #[doc = "           It\'s a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           If there is a need to use the same prefix multiple times, consider loadDictionary instead."]
-    #[doc = "  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation."]
-    pub fn ZSTD_CCtx_refPrefix(
-        cctx: *mut ZSTD_CCtx,
-        prefix: *const ::libc::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary() :"]
-    #[doc = "  Create an internal DDict from dict buffer,"]
-    #[doc = "  to be used to decompress next frames."]
-    #[doc = "  The dictionary remains valid for all future frames, until explicitly invalidated."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,"]
-    #[doc = "            meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Loading a dictionary involves building tables,"]
-    #[doc = "           which has a non-negligible impact on CPU usage and latency."]
-    #[doc = "           It\'s recommended to \"load once, use many times\", to amortize the cost"]
-    #[doc = "  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading."]
-    #[doc = "           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead."]
-    #[doc = "  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of"]
-    #[doc = "           how dictionary content is loaded and interpreted."]
-    pub fn ZSTD_DCtx_loadDictionary(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const ::libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refDDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used to decompress next frames."]
-    #[doc = "  The dictionary remains active for decompression of future frames using same DCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Special: referencing a NULL DDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."]
-    pub fn ZSTD_DCtx_refDDict(
-        dctx: *mut ZSTD_DCtx,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) to decompress next frame."]
-    #[doc = "  This is the reverse operation of ZSTD_CCtx_refPrefix(),"]
-    #[doc = "  and must use the same prefix as the one used during compression."]
-    #[doc = "  Prefix is **only used once**. Reference is discarded at end of frame."]
-    #[doc = "  End of frame is reached when ZSTD_decompressStream() returns 0."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary"]
-    #[doc = "  Note 2 : Prefix buffer is referenced. It **must** outlive decompression."]
-    #[doc = "           Prefix buffer must remain unmodified up to the end of frame,"]
-    #[doc = "           reached when ZSTD_decompressStream() returns 0."]
-    #[doc = "  Note 3 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)"]
-    #[doc = "  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost."]
-    #[doc = "           A full dictionary is more costly, as it requires building tables."]
-    pub fn ZSTD_DCtx_refPrefix(
-        dctx: *mut ZSTD_DCtx,
-        prefix: *const ::libc::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_sizeof_*() :"]
-    #[doc = "  These functions give the _current_ memory usage of selected object."]
-    #[doc = "  Note that object memory usage can evolve (increase or decrease) over time."]
-    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZDICT_trainFromBuffer():"]
-    #[doc = "  Train a dictionary from an array of samples."]
-    #[doc = "  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,"]
-    #[doc = "  f=20, and accel=1."]
-    #[doc = "  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,"]
-    #[doc = "  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order."]
-    #[doc = "  The resulting dictionary will be saved into `dictBuffer`."]
-    #[doc = " @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)"]
-    #[doc = "          or an error code, which can be tested with ZDICT_isError()."]
-    #[doc = "  Note:  Dictionary training will fail if there are not enough samples to construct a"]
-    #[doc = "         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit)."]
-    #[doc = "         If dictionary training fails, you should use zstd without a dictionary, as the dictionary"]
-    #[doc = "         would\'ve been ineffective anyways. If you believe your samples would benefit from a dictionary"]
-    #[doc = "         please open an issue with details, and we can look into it."]
-    #[doc = "  Note: ZDICT_trainFromBuffer()\'s memory usage is about 6 MB."]
-    #[doc = "  Tips: In general, a reasonable dictionary has a size of ~ 100 KB."]
-    #[doc = "        It\'s possible to select smaller or larger size, just by specifying `dictBufferCapacity`."]
-    #[doc = "        In general, it\'s recommended to provide a few thousands samples, though this can vary a lot."]
-    #[doc = "        It\'s recommended that total size of all samples be about ~x100 times the target size of dictionary."]
-    pub fn ZDICT_trainFromBuffer(
-        dictBuffer: *mut ::libc::c_void,
-        dictBufferCapacity: usize,
-        samplesBuffer: *const ::libc::c_void,
-        samplesSizes: *const usize,
-        nbSamples: ::libc::c_uint,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZDICT_getDictID(
-        dictBuffer: *const ::libc::c_void,
-        dictSize: usize,
-    ) -> ::libc::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_isError(errorCode: usize) -> ::libc::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_getErrorName(errorCode: usize) -> *const ::libc::c_char;
-}
Index: zstd-sys-1/src/bindings_experimental.rs
===================================================================
--- zstd-sys-1.orig/src/bindings_experimental.rs
+++ /dev/null
@@ -1,2661 +0,0 @@
-/* automatically generated by rust-bindgen */
-
-pub const ZSTD_VERSION_MAJOR: u32 = 1;
-pub const ZSTD_VERSION_MINOR: u32 = 4;
-pub const ZSTD_VERSION_RELEASE: u32 = 0;
-pub const ZSTD_VERSION_NUMBER: u32 = 10400;
-pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
-pub const ZSTD_MAGICNUMBER: u32 = 4247762216;
-pub const ZSTD_MAGIC_DICTIONARY: u32 = 3962610743;
-pub const ZSTD_MAGIC_SKIPPABLE_START: u32 = 407710288;
-pub const ZSTD_MAGIC_SKIPPABLE_MASK: u32 = 4294967280;
-pub const ZSTD_BLOCKSIZELOG_MAX: u32 = 17;
-pub const ZSTD_BLOCKSIZE_MAX: u32 = 131072;
-pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
-pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
-pub const ZSTD_FRAMEHEADERSIZE_PREFIX: u32 = 5;
-pub const ZSTD_FRAMEHEADERSIZE_MIN: u32 = 6;
-pub const ZSTD_FRAMEHEADERSIZE_MAX: u32 = 18;
-pub const ZSTD_SKIPPABLEHEADERSIZE: u32 = 8;
-pub const ZSTD_WINDOWLOG_MAX_32: u32 = 30;
-pub const ZSTD_WINDOWLOG_MAX_64: u32 = 31;
-pub const ZSTD_WINDOWLOG_MIN: u32 = 10;
-pub const ZSTD_HASHLOG_MIN: u32 = 6;
-pub const ZSTD_CHAINLOG_MAX_32: u32 = 29;
-pub const ZSTD_CHAINLOG_MAX_64: u32 = 30;
-pub const ZSTD_CHAINLOG_MIN: u32 = 6;
-pub const ZSTD_SEARCHLOG_MIN: u32 = 1;
-pub const ZSTD_MINMATCH_MAX: u32 = 7;
-pub const ZSTD_MINMATCH_MIN: u32 = 3;
-pub const ZSTD_TARGETLENGTH_MAX: u32 = 131072;
-pub const ZSTD_TARGETLENGTH_MIN: u32 = 0;
-pub const ZSTD_OVERLAPLOG_MIN: u32 = 0;
-pub const ZSTD_OVERLAPLOG_MAX: u32 = 9;
-pub const ZSTD_WINDOWLOG_LIMIT_DEFAULT: u32 = 27;
-pub const ZSTD_LDM_HASHLOG_MIN: u32 = 6;
-pub const ZSTD_LDM_MINMATCH_MIN: u32 = 4;
-pub const ZSTD_LDM_MINMATCH_MAX: u32 = 4096;
-pub const ZSTD_LDM_BUCKETSIZELOG_MIN: u32 = 1;
-pub const ZSTD_LDM_BUCKETSIZELOG_MAX: u32 = 8;
-pub const ZSTD_LDM_HASHRATELOG_MIN: u32 = 0;
-pub const ZSTD_HASHLOG3_MAX: u32 = 17;
-pub const ZSTDMT_NBWORKERS_MAX: u32 = 200;
-pub type wchar_t = libc::c_int;
-extern "C" {
-    pub fn ZSTD_versionNumber() -> libc::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_versionString() -> *const libc::c_char;
-}
-extern "C" {
-    #[doc = "  Simple API"]
-    #[doc = "  Compresses `src` content as a single zstd compressed frame into already allocated `dst`."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = "  @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "            or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress(
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress() :"]
-    #[doc = "  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames."]
-    #[doc = "  `dstCapacity` is an upper bound of originalSize to regenerate."]
-    #[doc = "  If user cannot imply a maximum upper bound, it\'s better to use streaming mode to decompress data."]
-    #[doc = "  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),"]
-    #[doc = "            or an errorCode if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_decompress(
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        compressedSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_getFrameContentSize(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> libc::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_getDecompressedSize() :"]
-    #[doc = "  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize()."]
-    #[doc = "  Both functions work the same way, but ZSTD_getDecompressedSize() blends"]
-    #[doc = "  \"empty\", \"unknown\" and \"error\" results to the same return value (0),"]
-    #[doc = "  while ZSTD_getFrameContentSize() gives them separate return values."]
-    #[doc = " @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."]
-    pub fn ZSTD_getDecompressedSize(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> libc::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_findFrameCompressedSize() :"]
-    #[doc = " `src` should point to the start of a ZSTD frame or skippable frame."]
-    #[doc = " `srcSize` must be >= first frame size"]
-    #[doc = " @return : the compressed size of the first frame starting at `src`,"]
-    #[doc = "           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,"]
-    #[doc = "        or an error code if input is invalid"]
-    pub fn ZSTD_findFrameCompressedSize(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_isError(code: usize) -> libc::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_getErrorName(code: usize) -> *const libc::c_char;
-}
-extern "C" {
-    pub fn ZSTD_minCLevel() -> libc::c_int;
-}
-extern "C" {
-    pub fn ZSTD_maxCLevel() -> libc::c_int;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CCtx_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Explicit context"]
-pub type ZSTD_CCtx = ZSTD_CCtx_s;
-extern "C" {
-    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compressCCtx() :"]
-    #[doc = "  Same as ZSTD_compress(), using an explicit ZSTD_CCtx"]
-    #[doc = "  The function will compress at requested compression level,"]
-    #[doc = "  ignoring any other parameter"]
-    pub fn ZSTD_compressCCtx(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DCtx_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DCtx = ZSTD_DCtx_s;
-extern "C" {
-    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressDCtx() :"]
-    #[doc = "  Same as ZSTD_decompress(),"]
-    #[doc = "  requires an allocated ZSTD_DCtx."]
-    #[doc = "  Compatible with sticky parameters."]
-    pub fn ZSTD_decompressDCtx(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced compression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_strategy {
-    ZSTD_fast = 1,
-    ZSTD_dfast = 2,
-    ZSTD_greedy = 3,
-    ZSTD_lazy = 4,
-    ZSTD_lazy2 = 5,
-    ZSTD_btlazy2 = 6,
-    ZSTD_btopt = 7,
-    ZSTD_btultra = 8,
-    ZSTD_btultra2 = 9,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_cParameter {
-    ZSTD_c_compressionLevel = 100,
-    ZSTD_c_windowLog = 101,
-    ZSTD_c_hashLog = 102,
-    ZSTD_c_chainLog = 103,
-    ZSTD_c_searchLog = 104,
-    ZSTD_c_minMatch = 105,
-    ZSTD_c_targetLength = 106,
-    ZSTD_c_strategy = 107,
-    ZSTD_c_enableLongDistanceMatching = 160,
-    ZSTD_c_ldmHashLog = 161,
-    ZSTD_c_ldmMinMatch = 162,
-    ZSTD_c_ldmBucketSizeLog = 163,
-    ZSTD_c_ldmHashRateLog = 164,
-    ZSTD_c_contentSizeFlag = 200,
-    ZSTD_c_checksumFlag = 201,
-    ZSTD_c_dictIDFlag = 202,
-    ZSTD_c_nbWorkers = 400,
-    ZSTD_c_jobSize = 401,
-    ZSTD_c_overlapLog = 402,
-    ZSTD_c_experimentalParam1 = 500,
-    ZSTD_c_experimentalParam2 = 10,
-    ZSTD_c_experimentalParam3 = 1000,
-    ZSTD_c_experimentalParam4 = 1001,
-    ZSTD_c_experimentalParam5 = 1002,
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_bounds {
-    pub error: usize,
-    pub lowerBound: libc::c_int,
-    pub upperBound: libc::c_int,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_bounds() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_bounds>(),
-        16usize,
-        concat!("Size of: ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_bounds>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).error as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(error)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).lowerBound as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(lowerBound)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).upperBound as *const _
-                as usize
-        },
-        12usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(upperBound)
-        )
-    );
-}
-extern "C" {
-    #[doc = " ZSTD_cParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - lower and upper bounds, both inclusive"]
-    pub fn ZSTD_cParam_getBounds(cParam: ZSTD_cParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is generally only possible during frame initialization (before starting compression)."]
-    #[doc = "  Exception : when using multi-threading mode (nbWorkers >= 1),"]
-    #[doc = "              the following parameters can be updated _during_ compression (within same frame):"]
-    #[doc = "              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy."]
-    #[doc = "              new parameters will be active for next job only (after a flush())."]
-    #[doc = " @return : an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_CCtx_setParameter(
-        cctx: *mut ZSTD_CCtx,
-        param: ZSTD_cParameter,
-        value: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setPledgedSrcSize() :"]
-    #[doc = "  Total input data size to be compressed as a single frame."]
-    #[doc = "  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag."]
-    #[doc = "  This value will also be controlled at end of frame, and trigger an error if not respected."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame."]
-    #[doc = "           In order to mean \"unknown content size\", pass constant ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame."]
-    #[doc = "  Note 2 : pledgedSrcSize is only valid once, for the next frame."]
-    #[doc = "           It\'s discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "  Note 3 : Whenever all input data is provided and consumed in a single round,"]
-    #[doc = "           for example with ZSTD_compress2(),"]
-    #[doc = "           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),"]
-    #[doc = "           this value is automatically overridden by srcSize instead."]
-    pub fn ZSTD_CCtx_setPledgedSrcSize(
-        cctx: *mut ZSTD_CCtx,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_ResetDirective {
-    ZSTD_reset_session_only = 1,
-    ZSTD_reset_parameters = 2,
-    ZSTD_reset_session_and_parameters = 3,
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_reset() :"]
-    #[doc = "  There are 2 different things that can be reset, independently or jointly :"]
-    #[doc = "  - The session : will stop compressing current frame, and make CCtx ready to start a new one."]
-    #[doc = "                  Useful after an error, or to interrupt any ongoing compression."]
-    #[doc = "                  Any internal data not yet flushed is cancelled."]
-    #[doc = "                  Compression parameters and dictionary remain unchanged."]
-    #[doc = "                  They will be used to compress next frame."]
-    #[doc = "                  Resetting session never fails."]
-    #[doc = "  - The parameters : changes all parameters back to \"default\"."]
-    #[doc = "                  This removes any reference to any dictionary too."]
-    #[doc = "                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)"]
-    #[doc = "                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())"]
-    #[doc = "  - Both : similar to resetting the session, followed by resetting parameters."]
-    pub fn ZSTD_CCtx_reset(
-        cctx: *mut ZSTD_CCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress2() :"]
-    #[doc = "  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API."]
-    #[doc = "  ZSTD_compress2() always starts a new frame."]
-    #[doc = "  Should cctx hold data from a previously unfinished frame, everything about it is forgotten."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - The function is always blocking, returns when compression is completed."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = " @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "           or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress2(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced decompression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dParameter {
-    ZSTD_d_windowLogMax = 100,
-    ZSTD_d_experimentalParam1 = 1000,
-}
-extern "C" {
-    #[doc = " ZSTD_dParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - both lower and upper bounds, inclusive"]
-    pub fn ZSTD_dParam_getBounds(dParam: ZSTD_dParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_dParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is only possible during frame initialization (before starting decompression)."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setParameter(
-        dctx: *mut ZSTD_DCtx,
-        param: ZSTD_dParameter,
-        value: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_reset() :"]
-    #[doc = "  Return a DCtx to clean state."]
-    #[doc = "  Session and parameters can be reset jointly or separately."]
-    #[doc = "  Parameters can only be reset when no active frame is being decompressed."]
-    #[doc = " @return : 0, or an error code, which can be tested with ZSTD_isError()"]
-    pub fn ZSTD_DCtx_reset(
-        dctx: *mut ZSTD_DCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-#[doc = "  Streaming"]
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_inBuffer_s {
-    #[doc = "< start of input buffer"]
-    pub src: *const libc::c_void,
-    #[doc = "< size of input buffer"]
-    pub size: usize,
-    #[doc = "< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_inBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_inBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_inBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).src as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(src)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_outBuffer_s {
-    #[doc = "< start of output buffer"]
-    pub dst: *mut libc::c_void,
-    #[doc = "< size of output buffer"]
-    pub size: usize,
-    #[doc = "< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_outBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_outBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_outBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).dst as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(dst)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
-pub type ZSTD_CStream = ZSTD_CCtx;
-extern "C" {
-    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_EndDirective {
-    ZSTD_e_continue = 0,
-    ZSTD_e_flush = 1,
-    ZSTD_e_end = 2,
-}
-extern "C" {
-    #[doc = " ZSTD_compressStream2() :"]
-    #[doc = "  Behaves about the same as ZSTD_compressStream, with additional control on end directive."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)"]
-    #[doc = "  - output->pos must be <= dstCapacity, input->pos must be <= srcSize"]
-    #[doc = "  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit."]
-    #[doc = "  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller."]
-    #[doc = "  - When nbWorkers>=1, function is non-blocking : it just acquires a copy of input, and distributes jobs to internal worker threads, flush whatever is available,"]
-    #[doc = "                                                  and then immediately returns, just indicating that there is some data remaining to be flushed."]
-    #[doc = "                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte."]
-    #[doc = "  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking."]
-    #[doc = "  - @return provides a minimum amount of data remaining to be flushed from internal buffers"]
-    #[doc = "            or an error code, which can be tested using ZSTD_isError()."]
-    #[doc = "            if @return != 0, flush is not fully completed, there is still some data left within internal buffers."]
-    #[doc = "            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers."]
-    #[doc = "            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed."]
-    #[doc = "  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),"]
-    #[doc = "            only ZSTD_e_end or ZSTD_e_flush operations are allowed."]
-    #[doc = "            Before starting a new compression job, or changing compression parameters,"]
-    #[doc = "            it is required to fully flush internal buffers."]
-    pub fn ZSTD_compressStream2(
-        cctx: *mut ZSTD_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    pub fn ZSTD_initCStream(
-        zcs: *mut ZSTD_CStream,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue)."]
-    #[doc = " NOTE: The return value is different. ZSTD_compressStream() returns a hint for"]
-    #[doc = " the next read size (if non-zero and not an error). ZSTD_compressStream2()"]
-    #[doc = " returns the number of bytes left to flush (if non-zero and not an error)."]
-    pub fn ZSTD_compressStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush)."]
-    pub fn ZSTD_flushStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end)."]
-    pub fn ZSTD_endStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-pub type ZSTD_DStream = ZSTD_DCtx;
-extern "C" {
-    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressStream(
-        zds: *mut ZSTD_DStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = "  Simple dictionary API"]
-    #[doc = "  Compression at an explicit compression level using a Dictionary."]
-    #[doc = "  A dictionary can be any arbitrary data segment (also called a prefix),"]
-    #[doc = "  or a buffer with specified information (see dictBuilder/zdict.h)."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_compress_usingDict(
-        ctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDict() :"]
-    #[doc = "  Decompression using a known Dictionary."]
-    #[doc = "  Dictionary must be identical to the one used during compression."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_decompress_usingDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CDict_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Bulk processing dictionary API"]
-pub type ZSTD_CDict = ZSTD_CDict_s;
-extern "C" {
-    #[doc = " ZSTD_createCDict() :"]
-    #[doc = "  When compressing multiple messages / blocks using the same dictionary, it\'s recommended to load it only once."]
-    #[doc = "  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup cost."]
-    #[doc = "  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only."]
-    #[doc = " `dictBuffer` can be released after ZSTD_CDict creation, because its content is copied within CDict."]
-    #[doc = "  Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate `dictBuffer` content."]
-    #[doc = "  Note : A ZSTD_CDict can be created from an empty dictBuffer, but it is inefficient when used to compress small data."]
-    pub fn ZSTD_createCDict(
-        dictBuffer: *const libc::c_void,
-        dictSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeCDict() :"]
-    #[doc = "  Function frees memory allocated by ZSTD_createCDict()."]
-    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_usingCDict() :"]
-    #[doc = "  Compression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    #[doc = "  Note : compression level is _decided at dictionary creation time_,"]
-    #[doc = "     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"]
-    pub fn ZSTD_compress_usingCDict(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DDict_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DDict = ZSTD_DDict_s;
-extern "C" {
-    #[doc = " ZSTD_createDDict() :"]
-    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
-    #[doc = "  dictBuffer can be released after DDict creation, as its content is copied inside DDict."]
-    pub fn ZSTD_createDDict(
-        dictBuffer: *const libc::c_void,
-        dictSize: usize,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeDDict() :"]
-    #[doc = "  Function frees memory allocated with ZSTD_createDDict()"]
-    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDDict() :"]
-    #[doc = "  Decompression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    pub fn ZSTD_decompress_usingDDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDict() :"]
-    #[doc = "  Provides the dictID stored within dictionary."]
-    #[doc = "  if @return == 0, the dictionary is not conformant with Zstandard specification."]
-    #[doc = "  It can still be loaded, but as a content-only dictionary."]
-    pub fn ZSTD_getDictID_fromDict(
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDDict() :"]
-    #[doc = "  Provides the dictID of the dictionary loaded into `ddict`."]
-    #[doc = "  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty."]
-    #[doc = "  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."]
-    pub fn ZSTD_getDictID_fromDDict(ddict: *const ZSTD_DDict) -> libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromFrame() :"]
-    #[doc = "  Provides the dictID required to decompressed the frame stored within `src`."]
-    #[doc = "  If @return == 0, the dictID could not be decoded."]
-    #[doc = "  This could for one of the following reasons :"]
-    #[doc = "  - The frame does not require a dictionary to be decoded (most common case)."]
-    #[doc = "  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information."]
-    #[doc = "    Note : this use case also happens when using a non-conformant dictionary."]
-    #[doc = "  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`)."]
-    #[doc = "  - This is not a Zstandard frame."]
-    #[doc = "  When identifying the exact failure cause, it\'s possible to use ZSTD_getFrameHeader(), which will provide a more precise error code."]
-    pub fn ZSTD_getDictID_fromFrame(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary() :"]
-    #[doc = "  Create an internal CDict from `dict` buffer."]
-    #[doc = "  Decompression will have to use same dictionary."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,"]
-    #[doc = "           meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Dictionary is sticky, it will be used for all future compressed frames."]
-    #[doc = "           To return to \"no-dictionary\" situation, load a NULL dictionary (or reset parameters)."]
-    #[doc = "  Note 2 : Loading a dictionary involves building tables."]
-    #[doc = "           It\'s also a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           Tables are dependent on compression parameters, and for this reason,"]
-    #[doc = "           compression parameters can no longer be changed after loading a dictionary."]
-    #[doc = "  Note 3 :`dict` content will be copied internally."]
-    #[doc = "           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead."]
-    #[doc = "           In such a case, dictionary buffer must outlive its users."]
-    #[doc = "  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()"]
-    #[doc = "           to precisely select how dictionary content must be interpreted."]
-    pub fn ZSTD_CCtx_loadDictionary(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refCDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used for all next compressed frames."]
-    #[doc = "  Note that compression parameters are enforced from within CDict,"]
-    #[doc = "  and supersede any compression parameter previously set within CCtx."]
-    #[doc = "  The parameters ignored are labled as \"superseded-by-cdict\" in the ZSTD_cParameter enum docs."]
-    #[doc = "  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode."]
-    #[doc = "  The dictionary will remain valid for future compressed frames using same CCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Referencing a NULL CDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx."]
-    pub fn ZSTD_CCtx_refCDict(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) for next compressed frame."]
-    #[doc = "  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end)."]
-    #[doc = "  Decompression will need same prefix to properly regenerate data."]
-    #[doc = "  Compressing with a prefix is similar in outcome as performing a diff and compressing it,"]
-    #[doc = "  but performs much faster, especially during decompression (compression speed is tunable with compression level)."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary"]
-    #[doc = "  Note 1 : Prefix buffer is referenced. It **must** outlive compression."]
-    #[doc = "           Its content must remain unmodified during compression."]
-    #[doc = "  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,"]
-    #[doc = "           ensure that the window size is large enough to contain the entire source."]
-    #[doc = "           See ZSTD_c_windowLog."]
-    #[doc = "  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters."]
-    #[doc = "           It\'s a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           If there is a need to use the same prefix multiple times, consider loadDictionary instead."]
-    #[doc = "  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation."]
-    pub fn ZSTD_CCtx_refPrefix(
-        cctx: *mut ZSTD_CCtx,
-        prefix: *const libc::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary() :"]
-    #[doc = "  Create an internal DDict from dict buffer,"]
-    #[doc = "  to be used to decompress next frames."]
-    #[doc = "  The dictionary remains valid for all future frames, until explicitly invalidated."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,"]
-    #[doc = "            meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Loading a dictionary involves building tables,"]
-    #[doc = "           which has a non-negligible impact on CPU usage and latency."]
-    #[doc = "           It\'s recommended to \"load once, use many times\", to amortize the cost"]
-    #[doc = "  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading."]
-    #[doc = "           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead."]
-    #[doc = "  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of"]
-    #[doc = "           how dictionary content is loaded and interpreted."]
-    pub fn ZSTD_DCtx_loadDictionary(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refDDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used to decompress next frames."]
-    #[doc = "  The dictionary remains active for decompression of future frames using same DCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Special: referencing a NULL DDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."]
-    pub fn ZSTD_DCtx_refDDict(
-        dctx: *mut ZSTD_DCtx,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) to decompress next frame."]
-    #[doc = "  This is the reverse operation of ZSTD_CCtx_refPrefix(),"]
-    #[doc = "  and must use the same prefix as the one used during compression."]
-    #[doc = "  Prefix is **only used once**. Reference is discarded at end of frame."]
-    #[doc = "  End of frame is reached when ZSTD_decompressStream() returns 0."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary"]
-    #[doc = "  Note 2 : Prefix buffer is referenced. It **must** outlive decompression."]
-    #[doc = "           Prefix buffer must remain unmodified up to the end of frame,"]
-    #[doc = "           reached when ZSTD_decompressStream() returns 0."]
-    #[doc = "  Note 3 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)"]
-    #[doc = "  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost."]
-    #[doc = "           A full dictionary is more costly, as it requires building tables."]
-    pub fn ZSTD_DCtx_refPrefix(
-        dctx: *mut ZSTD_DCtx,
-        prefix: *const libc::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_sizeof_*() :"]
-    #[doc = "  These functions give the _current_ memory usage of selected object."]
-    #[doc = "  Note that object memory usage can evolve (increase or decrease) over time."]
-    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CCtx_params_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_CCtx_params = ZSTD_CCtx_params_s;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_compressionParameters {
-    #[doc = "< largest match distance : larger == more compression, more memory needed during decompression"]
-    pub windowLog: libc::c_uint,
-    #[doc = "< fully searched segment : larger == more compression, slower, more memory (useless for fast)"]
-    pub chainLog: libc::c_uint,
-    #[doc = "< dispatch table : larger == faster, more memory"]
-    pub hashLog: libc::c_uint,
-    #[doc = "< nb of searches : larger == more compression, slower"]
-    pub searchLog: libc::c_uint,
-    #[doc = "< match length searched : larger == faster decompression, sometimes less compression"]
-    pub minMatch: libc::c_uint,
-    #[doc = "< acceptable match size for optimal parser (only) : larger == more compression, slower"]
-    pub targetLength: libc::c_uint,
-    #[doc = "< see ZSTD_strategy definition above"]
-    pub strategy: ZSTD_strategy,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_compressionParameters() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_compressionParameters>(),
-        28usize,
-        concat!("Size of: ", stringify!(ZSTD_compressionParameters))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_compressionParameters>(),
-        4usize,
-        concat!("Alignment of ", stringify!(ZSTD_compressionParameters))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).windowLog
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(windowLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).chainLog
-                as *const _ as usize
-        },
-        4usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(chainLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).hashLog
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(hashLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).searchLog
-                as *const _ as usize
-        },
-        12usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(searchLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).minMatch
-                as *const _ as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(minMatch)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>()))
-                .targetLength as *const _ as usize
-        },
-        20usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(targetLength)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).strategy
-                as *const _ as usize
-        },
-        24usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(strategy)
-        )
-    );
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_frameParameters {
-    #[doc = "< 1: content size will be in frame header (when known)"]
-    pub contentSizeFlag: libc::c_int,
-    #[doc = "< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection"]
-    pub checksumFlag: libc::c_int,
-    #[doc = "< 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression)"]
-    pub noDictIDFlag: libc::c_int,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_frameParameters() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_frameParameters>(),
-        12usize,
-        concat!("Size of: ", stringify!(ZSTD_frameParameters))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_frameParameters>(),
-        4usize,
-        concat!("Alignment of ", stringify!(ZSTD_frameParameters))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameParameters>())).contentSizeFlag
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameParameters),
-            "::",
-            stringify!(contentSizeFlag)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameParameters>())).checksumFlag
-                as *const _ as usize
-        },
-        4usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameParameters),
-            "::",
-            stringify!(checksumFlag)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameParameters>())).noDictIDFlag
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameParameters),
-            "::",
-            stringify!(noDictIDFlag)
-        )
-    );
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_parameters {
-    pub cParams: ZSTD_compressionParameters,
-    pub fParams: ZSTD_frameParameters,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_parameters() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_parameters>(),
-        40usize,
-        concat!("Size of: ", stringify!(ZSTD_parameters))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_parameters>(),
-        4usize,
-        concat!("Alignment of ", stringify!(ZSTD_parameters))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_parameters>())).cParams as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_parameters),
-            "::",
-            stringify!(cParams)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_parameters>())).fParams as *const _
-                as usize
-        },
-        28usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_parameters),
-            "::",
-            stringify!(fParams)
-        )
-    );
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dictContentType_e {
-    ZSTD_dct_auto = 0,
-    ZSTD_dct_rawContent = 1,
-    ZSTD_dct_fullDict = 2,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dictLoadMethod_e {
-    #[doc = "< Copy dictionary content internally"]
-    ZSTD_dlm_byCopy = 0,
-    #[doc = "< Reference dictionary content -- the dictionary buffer must outlive its users."]
-    ZSTD_dlm_byRef = 1,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_format_e {
-    ZSTD_f_zstd1 = 0,
-    ZSTD_f_zstd1_magicless = 1,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dictAttachPref_e {
-    ZSTD_dictDefaultAttach = 0,
-    ZSTD_dictForceAttach = 1,
-    ZSTD_dictForceCopy = 2,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_literalCompressionMode_e {
-    #[doc = "< Automatically determine the compression mode based on the compression level."]
-    #[doc = "   Negative compression levels will be uncompressed, and positive compression"]
-    #[doc = "   levels will be compressed."]
-    ZSTD_lcm_auto = 0,
-    #[doc = "< Always attempt Huffman compression. Uncompressed literals will still be"]
-    #[doc = "   emitted if Huffman compression is not profitable."]
-    ZSTD_lcm_huffman = 1,
-    #[doc = "< Always emit uncompressed literals."]
-    ZSTD_lcm_uncompressed = 2,
-}
-extern "C" {
-    #[doc = " ZSTD_findDecompressedSize() :"]
-    #[doc = "  `src` should point to the start of a series of ZSTD encoded and/or skippable frames"]
-    #[doc = "  `srcSize` must be the _exact_ size of this series"]
-    #[doc = "       (i.e. there should be a frame boundary at `src + srcSize`)"]
-    #[doc = "  @return : - decompressed size of all data in all successive frames"]
-    #[doc = "            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN"]
-    #[doc = "            - if an error occurred: ZSTD_CONTENTSIZE_ERROR"]
-    #[doc = ""]
-    #[doc = "   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode."]
-    #[doc = "            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size."]
-    #[doc = "            In which case, it\'s necessary to use streaming mode to decompress data."]
-    #[doc = "   note 2 : decompressed size is always present when compression is done with ZSTD_compress()"]
-    #[doc = "   note 3 : decompressed size can be very large (64-bits value),"]
-    #[doc = "            potentially larger than what local system can handle as a single memory segment."]
-    #[doc = "            In which case, it\'s necessary to use streaming mode to decompress data."]
-    #[doc = "   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified."]
-    #[doc = "            Always ensure result fits within application\'s authorized limits."]
-    #[doc = "            Each application can set its own limits."]
-    #[doc = "   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to"]
-    #[doc = "            read each contained frame header.  This is fast as most of the data is skipped,"]
-    #[doc = "            however it does mean that all frame data must be present and valid."]
-    pub fn ZSTD_findDecompressedSize(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> libc::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressBound() :"]
-    #[doc = "  `src` should point to the start of a series of ZSTD encoded and/or skippable frames"]
-    #[doc = "  `srcSize` must be the _exact_ size of this series"]
-    #[doc = "       (i.e. there should be a frame boundary at `src + srcSize`)"]
-    #[doc = "  @return : - upper-bound for the decompressed size of all data in all successive frames"]
-    #[doc = "            - if an error occured: ZSTD_CONTENTSIZE_ERROR"]
-    #[doc = ""]
-    #[doc = "  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame."]
-    #[doc = "  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`."]
-    #[doc = "            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value."]
-    #[doc = "  note 3  : when the decompressed size field isn\'t available, the upper-bound for that frame is calculated by:"]
-    #[doc = "              upper-bound = # blocks * min(128 KB, Window_Size)"]
-    pub fn ZSTD_decompressBound(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> libc::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_frameHeaderSize() :"]
-    #[doc = "  srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX."]
-    #[doc = " @return : size of the Frame Header,"]
-    #[doc = "           or an error code (if srcSize is too small)"]
-    pub fn ZSTD_frameHeaderSize(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_estimate*() :"]
-    #[doc = "  These functions make it possible to estimate memory usage"]
-    #[doc = "  of a future {D,C}Ctx, before its creation."]
-    #[doc = "  ZSTD_estimateCCtxSize() will provide a budget large enough for any compression level up to selected one."]
-    #[doc = "  It will also consider src size to be arbitrarily \"large\", which is worst case."]
-    #[doc = "  If srcSize is known to always be small, ZSTD_estimateCCtxSize_usingCParams() can provide a tighter estimation."]
-    #[doc = "  ZSTD_estimateCCtxSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel."]
-    #[doc = "  ZSTD_estimateCCtxSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1."]
-    #[doc = "  Note : CCtx size estimation is only correct for single-threaded compression."]
-    pub fn ZSTD_estimateCCtxSize(compressionLevel: libc::c_int) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCCtxSize_usingCParams(
-        cParams: ZSTD_compressionParameters,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCCtxSize_usingCCtxParams(
-        params: *const ZSTD_CCtx_params,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDCtxSize() -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_estimateCStreamSize() :"]
-    #[doc = "  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one."]
-    #[doc = "  It will also consider src size to be arbitrarily \"large\", which is worst case."]
-    #[doc = "  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation."]
-    #[doc = "  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel."]
-    #[doc = "  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1."]
-    #[doc = "  Note : CStream size estimation is only correct for single-threaded compression."]
-    #[doc = "  ZSTD_DStream memory budget depends on window Size."]
-    #[doc = "  This information can be passed manually, using ZSTD_estimateDStreamSize,"]
-    #[doc = "  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();"]
-    #[doc = "  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),"]
-    #[doc = "         an internal ?Dict will be created, which additional size is not estimated here."]
-    #[doc = "         In this case, get total size by adding ZSTD_estimate?DictSize"]
-    pub fn ZSTD_estimateCStreamSize(compressionLevel: libc::c_int) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCStreamSize_usingCParams(
-        cParams: ZSTD_compressionParameters,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCStreamSize_usingCCtxParams(
-        params: *const ZSTD_CCtx_params,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDStreamSize(windowSize: usize) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDStreamSize_fromFrame(
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_estimate?DictSize() :"]
-    #[doc = "  ZSTD_estimateCDictSize() will bet that src size is relatively \"small\", and content is copied, like ZSTD_createCDict()."]
-    #[doc = "  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced()."]
-    #[doc = "  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller."]
-    pub fn ZSTD_estimateCDictSize(
-        dictSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCDictSize_advanced(
-        dictSize: usize,
-        cParams: ZSTD_compressionParameters,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDDictSize(
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initStatic*() :"]
-    #[doc = "  Initialize an object using a pre-allocated fixed-size buffer."]
-    #[doc = "  workspace: The memory area to emplace the object into."]
-    #[doc = "             Provided pointer *must be 8-bytes aligned*."]
-    #[doc = "             Buffer must outlive object."]
-    #[doc = "  workspaceSize: Use ZSTD_estimate*Size() to determine"]
-    #[doc = "                 how large workspace must be to support target scenario."]
-    #[doc = " @return : pointer to object (same address as workspace, just different type),"]
-    #[doc = "           or NULL if error (size too small, incorrect alignment, etc.)"]
-    #[doc = "  Note : zstd will never resize nor malloc() when using a static buffer."]
-    #[doc = "         If the object requires more memory than available,"]
-    #[doc = "         zstd will just error out (typically ZSTD_error_memory_allocation)."]
-    #[doc = "  Note 2 : there is no corresponding \"free\" function."]
-    #[doc = "           Since workspace is allocated externally, it must be freed externally too."]
-    #[doc = "  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level"]
-    #[doc = "           into its associated cParams."]
-    #[doc = "  Limitation 1 : currently not compatible with internal dictionary creation, triggered by"]
-    #[doc = "                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict()."]
-    #[doc = "  Limitation 2 : static cctx currently not compatible with multi-threading."]
-    #[doc = "  Limitation 3 : static dctx is incompatible with legacy support."]
-    pub fn ZSTD_initStaticCCtx(
-        workspace: *mut libc::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_initStaticCStream(
-        workspace: *mut libc::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_initStaticDCtx(
-        workspace: *mut libc::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_initStaticDStream(
-        workspace: *mut libc::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_initStaticCDict(
-        workspace: *mut libc::c_void,
-        workspaceSize: usize,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-        cParams: ZSTD_compressionParameters,
-    ) -> *const ZSTD_CDict;
-}
-extern "C" {
-    pub fn ZSTD_initStaticDDict(
-        workspace: *mut libc::c_void,
-        workspaceSize: usize,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> *const ZSTD_DDict;
-}
-#[doc = " Custom memory allocation :"]
-#[doc = "  These prototypes make it possible to pass your own allocation/free functions."]
-#[doc = "  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below."]
-#[doc = "  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones."]
-pub type ZSTD_allocFunction = ::core::option::Option<
-    unsafe extern "C" fn(
-        opaque: *mut libc::c_void,
-        size: usize,
-    ) -> *mut libc::c_void,
->;
-pub type ZSTD_freeFunction = ::core::option::Option<
-    unsafe extern "C" fn(
-        opaque: *mut libc::c_void,
-        address: *mut libc::c_void,
-    ),
->;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_customMem {
-    pub customAlloc: ZSTD_allocFunction,
-    pub customFree: ZSTD_freeFunction,
-    pub opaque: *mut libc::c_void,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_customMem() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_customMem>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_customMem))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_customMem>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_customMem))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_customMem>())).customAlloc as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_customMem),
-            "::",
-            stringify!(customAlloc)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_customMem>())).customFree as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_customMem),
-            "::",
-            stringify!(customFree)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_customMem>())).opaque as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_customMem),
-            "::",
-            stringify!(opaque)
-        )
-    );
-}
-extern "C" {
-    #[link_name = "\u{1}ZSTD_defaultCMem"]
-    pub static ZSTD_defaultCMem: ZSTD_customMem;
-}
-extern "C" {
-    pub fn ZSTD_createCCtx_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_createCStream_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_createDCtx_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_createDStream_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_createCDict_advanced(
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-        cParams: ZSTD_compressionParameters,
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    pub fn ZSTD_createDDict_advanced(
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_createCDict_byReference() :"]
-    #[doc = "  Create a digested dictionary for compression"]
-    #[doc = "  Dictionary content is just referenced, not duplicated."]
-    #[doc = "  As a consequence, `dictBuffer` **must** outlive CDict,"]
-    #[doc = "  and its content must remain unmodified throughout the lifetime of CDict."]
-    pub fn ZSTD_createCDict_byReference(
-        dictBuffer: *const libc::c_void,
-        dictSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    #[doc = " ZSTD_getCParams() :"]
-    #[doc = " @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize."]
-    #[doc = " `estimatedSrcSize` value is optional, select 0 if not known"]
-    pub fn ZSTD_getCParams(
-        compressionLevel: libc::c_int,
-        estimatedSrcSize: libc::c_ulonglong,
-        dictSize: usize,
-    ) -> ZSTD_compressionParameters;
-}
-extern "C" {
-    #[doc = " ZSTD_getParams() :"]
-    #[doc = "  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`."]
-    #[doc = "  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0"]
-    pub fn ZSTD_getParams(
-        compressionLevel: libc::c_int,
-        estimatedSrcSize: libc::c_ulonglong,
-        dictSize: usize,
-    ) -> ZSTD_parameters;
-}
-extern "C" {
-    #[doc = " ZSTD_checkCParams() :"]
-    #[doc = "  Ensure param values remain within authorized range."]
-    #[doc = " @return 0 on success, or an error code (can be checked with ZSTD_isError())"]
-    pub fn ZSTD_checkCParams(params: ZSTD_compressionParameters) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_adjustCParams() :"]
-    #[doc = "  optimize params for a given `srcSize` and `dictSize`."]
-    #[doc = " `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = " `dictSize` must be `0` when there is no dictionary."]
-    #[doc = "  cPar can be invalid : all parameters will be clamped within valid range in the @return struct."]
-    #[doc = "  This function never fails (wide contract)"]
-    pub fn ZSTD_adjustCParams(
-        cPar: ZSTD_compressionParameters,
-        srcSize: libc::c_ulonglong,
-        dictSize: usize,
-    ) -> ZSTD_compressionParameters;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_advanced() :"]
-    #[doc = "  Same as ZSTD_compress_usingDict(), with fine-tune control over compression parameters (by structure)"]
-    pub fn ZSTD_compress_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_usingCDict_advanced() :"]
-    #[doc = "  Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters"]
-    pub fn ZSTD_compress_usingCDict_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-        fParams: ZSTD_frameParameters,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary_byReference() :"]
-    #[doc = "  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx."]
-    #[doc = "  It saves some memory, but also requires that `dict` outlives its usage within `cctx`"]
-    pub fn ZSTD_CCtx_loadDictionary_byReference(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary_advanced() :"]
-    #[doc = "  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over"]
-    #[doc = "  how to load the dictionary (by copy ? by reference ?)"]
-    #[doc = "  and how to interpret it (automatic ? force raw mode ? full mode only ?)"]
-    pub fn ZSTD_CCtx_loadDictionary_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refPrefix_advanced() :"]
-    #[doc = "  Same as ZSTD_CCtx_refPrefix(), but gives finer control over"]
-    #[doc = "  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"]
-    pub fn ZSTD_CCtx_refPrefix_advanced(
-        cctx: *mut ZSTD_CCtx,
-        prefix: *const libc::c_void,
-        prefixSize: usize,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_getParameter() :"]
-    #[doc = "  Get the requested compression parameter value, selected by enum ZSTD_cParameter,"]
-    #[doc = "  and store it into int* value."]
-    #[doc = " @return : 0, or an error code (which can be tested with ZSTD_isError())."]
-    pub fn ZSTD_CCtx_getParameter(
-        cctx: *mut ZSTD_CCtx,
-        param: ZSTD_cParameter,
-        value: *mut libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_params :"]
-    #[doc = "  Quick howto :"]
-    #[doc = "  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure"]
-    #[doc = "  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into"]
-    #[doc = "                                     an existing ZSTD_CCtx_params structure."]
-    #[doc = "                                     This is similar to"]
-    #[doc = "                                     ZSTD_CCtx_setParameter()."]
-    #[doc = "  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to"]
-    #[doc = "                                    an existing CCtx."]
-    #[doc = "                                    These parameters will be applied to"]
-    #[doc = "                                    all subsequent frames."]
-    #[doc = "  - ZSTD_compressStream2() : Do compression using the CCtx."]
-    #[doc = "  - ZSTD_freeCCtxParams() : Free the memory."]
-    #[doc = ""]
-    #[doc = "  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()"]
-    #[doc = "  for static allocation of CCtx for single-threaded compression."]
-    pub fn ZSTD_createCCtxParams() -> *mut ZSTD_CCtx_params;
-}
-extern "C" {
-    pub fn ZSTD_freeCCtxParams(params: *mut ZSTD_CCtx_params) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_reset() :"]
-    #[doc = "  Reset params to default values."]
-    pub fn ZSTD_CCtxParams_reset(params: *mut ZSTD_CCtx_params) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_init() :"]
-    #[doc = "  Initializes the compression parameters of cctxParams according to"]
-    #[doc = "  compression level. All other parameters are reset to their default values."]
-    pub fn ZSTD_CCtxParams_init(
-        cctxParams: *mut ZSTD_CCtx_params,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_init_advanced() :"]
-    #[doc = "  Initializes the compression and frame parameters of cctxParams according to"]
-    #[doc = "  params. All other parameters are reset to their default values."]
-    pub fn ZSTD_CCtxParams_init_advanced(
-        cctxParams: *mut ZSTD_CCtx_params,
-        params: ZSTD_parameters,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_setParameter() :"]
-    #[doc = "  Similar to ZSTD_CCtx_setParameter."]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = "  Parameters must be applied to a ZSTD_CCtx using ZSTD_CCtx_setParametersUsingCCtxParams()."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    pub fn ZSTD_CCtxParams_setParameter(
-        params: *mut ZSTD_CCtx_params,
-        param: ZSTD_cParameter,
-        value: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_getParameter() :"]
-    #[doc = " Similar to ZSTD_CCtx_getParameter."]
-    #[doc = " Get the requested value of one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    pub fn ZSTD_CCtxParams_getParameter(
-        params: *mut ZSTD_CCtx_params,
-        param: ZSTD_cParameter,
-        value: *mut libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setParametersUsingCCtxParams() :"]
-    #[doc = "  Apply a set of ZSTD_CCtx_params to the compression context."]
-    #[doc = "  This can be done even after compression is started,"]
-    #[doc = "    if nbWorkers==0, this will have no impact until a new compression is started."]
-    #[doc = "    if nbWorkers>=1, new parameters will be picked up at next job,"]
-    #[doc = "       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated)."]
-    pub fn ZSTD_CCtx_setParametersUsingCCtxParams(
-        cctx: *mut ZSTD_CCtx,
-        params: *const ZSTD_CCtx_params,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compressStream2_simpleArgs() :"]
-    #[doc = "  Same as ZSTD_compressStream2(),"]
-    #[doc = "  but using only integral types as arguments."]
-    #[doc = "  This variant might be helpful for binders from dynamic languages"]
-    #[doc = "  which have troubles handling structures containing memory pointers."]
-    pub fn ZSTD_compressStream2_simpleArgs(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        dstPos: *mut usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        srcPos: *mut usize,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_isFrame() :"]
-    #[doc = "  Tells if the content of `buffer` starts with a valid Frame Identifier."]
-    #[doc = "  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0."]
-    #[doc = "  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled."]
-    #[doc = "  Note 3 : Skippable Frame Identifiers are considered valid."]
-    pub fn ZSTD_isFrame(
-        buffer: *const libc::c_void,
-        size: usize,
-    ) -> libc::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_createDDict_byReference() :"]
-    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
-    #[doc = "  Dictionary content is referenced, and therefore stays in dictBuffer."]
-    #[doc = "  It is important that dictBuffer outlives DDict,"]
-    #[doc = "  it must remain read accessible throughout the lifetime of DDict"]
-    pub fn ZSTD_createDDict_byReference(
-        dictBuffer: *const libc::c_void,
-        dictSize: usize,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary_byReference() :"]
-    #[doc = "  Same as ZSTD_DCtx_loadDictionary(),"]
-    #[doc = "  but references `dict` content instead of copying it into `dctx`."]
-    #[doc = "  This saves memory if `dict` remains around.,"]
-    #[doc = "  However, it\'s imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression."]
-    pub fn ZSTD_DCtx_loadDictionary_byReference(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary_advanced() :"]
-    #[doc = "  Same as ZSTD_DCtx_loadDictionary(),"]
-    #[doc = "  but gives direct control over"]
-    #[doc = "  how to load the dictionary (by copy ? by reference ?)"]
-    #[doc = "  and how to interpret it (automatic ? force raw mode ? full mode only ?)."]
-    pub fn ZSTD_DCtx_loadDictionary_advanced(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refPrefix_advanced() :"]
-    #[doc = "  Same as ZSTD_DCtx_refPrefix(), but gives finer control over"]
-    #[doc = "  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"]
-    pub fn ZSTD_DCtx_refPrefix_advanced(
-        dctx: *mut ZSTD_DCtx,
-        prefix: *const libc::c_void,
-        prefixSize: usize,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setMaxWindowSize() :"]
-    #[doc = "  Refuses allocating internal buffers for frames requiring a window size larger than provided limit."]
-    #[doc = "  This protects a decoder context from reserving too much memory for itself (potential attack scenario)."]
-    #[doc = "  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode."]
-    #[doc = "  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)"]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setMaxWindowSize(
-        dctx: *mut ZSTD_DCtx,
-        maxWindowSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setFormat() :"]
-    #[doc = "  Instruct the decoder context about what kind of data to decode next."]
-    #[doc = "  This instruction is mandatory to decode data without a fully-formed header,"]
-    #[doc = "  such ZSTD_f_zstd1_magicless for example."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setFormat(
-        dctx: *mut ZSTD_DCtx,
-        format: ZSTD_format_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressStream_simpleArgs() :"]
-    #[doc = "  Same as ZSTD_decompressStream(),"]
-    #[doc = "  but using only integral types as arguments."]
-    #[doc = "  This can be helpful for binders from dynamic languages"]
-    #[doc = "  which have troubles handling structures containing memory pointers."]
-    pub fn ZSTD_decompressStream_simpleArgs(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        dstPos: *mut usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        srcPos: *mut usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_srcSize() :"]
-    #[doc = " This function is deprecated, and equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = ""]
-    #[doc = " pledgedSrcSize must be correct. If it is not known at init time, use"]
-    #[doc = " ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,"]
-    #[doc = " \"0\" also disables frame content size field. It may be enabled in the future."]
-    pub fn ZSTD_initCStream_srcSize(
-        zcs: *mut ZSTD_CStream,
-        compressionLevel: libc::c_int,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_usingDict() :"]
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    #[doc = "     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);"]
-    #[doc = ""]
-    #[doc = " Creates of an internal CDict (incompatible with static CCtx), except if"]
-    #[doc = " dict == NULL or dictSize < 8, in which case no dict is used."]
-    #[doc = " Note: dict is loaded with ZSTD_dm_auto (treated as a full zstd dictionary if"]
-    #[doc = " it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy."]
-    pub fn ZSTD_initCStream_usingDict(
-        zcs: *mut ZSTD_CStream,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_advanced() :"]
-    #[doc = " This function is deprecated, and is approximately equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setZstdParams(zcs, params); // Set the zstd params and leave the rest as-is"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = "     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);"]
-    #[doc = ""]
-    #[doc = " pledgedSrcSize must be correct. If srcSize is not known at init time, use"]
-    #[doc = " value ZSTD_CONTENTSIZE_UNKNOWN. dict is loaded with ZSTD_dm_auto and ZSTD_dlm_byCopy."]
-    pub fn ZSTD_initCStream_advanced(
-        zcs: *mut ZSTD_CStream,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_usingCDict() :"]
-    #[doc = " This function is deprecated, and equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, cdict);"]
-    #[doc = ""]
-    #[doc = " note : cdict will just be referenced, and must outlive compression session"]
-    pub fn ZSTD_initCStream_usingCDict(
-        zcs: *mut ZSTD_CStream,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_usingCDict_advanced() :"]
-    #[doc = " This function is deprecated, and is approximately equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setZstdFrameParams(zcs, fParams); // Set the zstd frame params and leave the rest as-is"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, cdict);"]
-    #[doc = ""]
-    #[doc = " same as ZSTD_initCStream_usingCDict(), with control over frame parameters."]
-    #[doc = " pledgedSrcSize must be correct. If srcSize is not known at init time, use"]
-    #[doc = " value ZSTD_CONTENTSIZE_UNKNOWN."]
-    pub fn ZSTD_initCStream_usingCDict_advanced(
-        zcs: *mut ZSTD_CStream,
-        cdict: *const ZSTD_CDict,
-        fParams: ZSTD_frameParameters,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_resetCStream() :"]
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = ""]
-    #[doc = "  start a new frame, using same parameters from previous frame."]
-    #[doc = "  This is typically useful to skip dictionary loading stage, since it will re-use it in-place."]
-    #[doc = "  Note that zcs must be init at least once before using ZSTD_resetCStream()."]
-    #[doc = "  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end."]
-    #[doc = "  For the time being, pledgedSrcSize==0 is interpreted as \"srcSize unknown\" for compatibility with older programs,"]
-    #[doc = "  but it will change to mean \"empty\" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())"]
-    pub fn ZSTD_resetCStream(
-        zcs: *mut ZSTD_CStream,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_frameProgression {
-    pub ingested: libc::c_ulonglong,
-    pub consumed: libc::c_ulonglong,
-    pub produced: libc::c_ulonglong,
-    pub flushed: libc::c_ulonglong,
-    pub currentJobID: libc::c_uint,
-    pub nbActiveWorkers: libc::c_uint,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_frameProgression() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_frameProgression>(),
-        40usize,
-        concat!("Size of: ", stringify!(ZSTD_frameProgression))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_frameProgression>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_frameProgression))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).ingested
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(ingested)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).consumed
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(consumed)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).produced
-                as *const _ as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(produced)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).flushed
-                as *const _ as usize
-        },
-        24usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(flushed)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).currentJobID
-                as *const _ as usize
-        },
-        32usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(currentJobID)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).nbActiveWorkers
-                as *const _ as usize
-        },
-        36usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(nbActiveWorkers)
-        )
-    );
-}
-extern "C" {
-    pub fn ZSTD_getFrameProgression(
-        cctx: *const ZSTD_CCtx,
-    ) -> ZSTD_frameProgression;
-}
-extern "C" {
-    #[doc = " ZSTD_toFlushNow() :"]
-    #[doc = "  Tell how many bytes are ready to be flushed immediately."]
-    #[doc = "  Useful for multithreading scenarios (nbWorkers >= 1)."]
-    #[doc = "  Probe the oldest active job, defined as oldest job not yet entirely flushed,"]
-    #[doc = "  and check its output buffer."]
-    #[doc = " @return : amount of data stored in oldest job and ready to be flushed immediately."]
-    #[doc = "  if @return == 0, it means either :"]
-    #[doc = "  + there is no active job (could be checked with ZSTD_frameProgression()), or"]
-    #[doc = "  + oldest job is still actively compressing data,"]
-    #[doc = "    but everything it has produced has also been flushed so far,"]
-    #[doc = "    therefore flush speed is limited by production speed of oldest job"]
-    #[doc = "    irrespective of the speed of concurrent (and newer) jobs."]
-    pub fn ZSTD_toFlushNow(cctx: *mut ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);"]
-    #[doc = ""]
-    #[doc = " note: no dictionary will be used if dict == NULL or dictSize < 8"]
-    pub fn ZSTD_initDStream_usingDict(
-        zds: *mut ZSTD_DStream,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_DCtx_refDDict(zds, ddict);"]
-    #[doc = ""]
-    #[doc = " note : ddict is referenced, it must outlive decompression session"]
-    pub fn ZSTD_initDStream_usingDDict(
-        zds: *mut ZSTD_DStream,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);"]
-    #[doc = ""]
-    #[doc = " re-use decompression parameters from previous init; saves dictionary loading"]
-    pub fn ZSTD_resetDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    #[doc = "Buffer-less streaming compression (synchronous mode)"]
-    #[doc = ""]
-    #[doc = "A ZSTD_CCtx object is required to track streaming operations."]
-    #[doc = "Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource."]
-    #[doc = "ZSTD_CCtx object can be re-used multiple times within successive compression operations."]
-    #[doc = ""]
-    #[doc = "Start by initializing a context."]
-    #[doc = "Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,"]
-    #[doc = "or ZSTD_compressBegin_advanced(), for finer parameter control."]
-    #[doc = "It\'s also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()"]
-    #[doc = ""]
-    #[doc = "Then, consume your input using ZSTD_compressContinue()."]
-    #[doc = "There are some important considerations to keep in mind when using this advanced function :"]
-    #[doc = "- ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only."]
-    #[doc = "- Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks."]
-    #[doc = "- Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario."]
-    #[doc = "Worst case evaluation is provided by ZSTD_compressBound()."]
-    #[doc = "ZSTD_compressContinue() doesn\'t guarantee recover after a failed compression."]
-    #[doc = "- ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog)."]
-    #[doc = "It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)"]
-    #[doc = "- ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps."]
-    #[doc = "In which case, it will \"discard\" the relevant memory section from its history."]
-    #[doc = ""]
-    #[doc = "Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum."]
-    #[doc = "It\'s possible to use srcSize==0, in which case, it will write a final empty block to end the frame."]
-    #[doc = "Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders."]
-    #[doc = ""]
-    #[doc = "`ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again."]
-    pub fn ZSTD_compressBegin(
-        cctx: *mut ZSTD_CCtx,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_usingDict(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_usingCDict(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_usingCDict_advanced(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-        fParams: ZSTD_frameParameters,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_copyCCtx(
-        cctx: *mut ZSTD_CCtx,
-        preparedCCtx: *const ZSTD_CCtx,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressContinue(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressEnd(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_frameType_e {
-    ZSTD_frame = 0,
-    ZSTD_skippableFrame = 1,
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_frameHeader {
-    pub frameContentSize: libc::c_ulonglong,
-    pub windowSize: libc::c_ulonglong,
-    pub blockSizeMax: libc::c_uint,
-    pub frameType: ZSTD_frameType_e,
-    pub headerSize: libc::c_uint,
-    pub dictID: libc::c_uint,
-    pub checksumFlag: libc::c_uint,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_frameHeader() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_frameHeader>(),
-        40usize,
-        concat!("Size of: ", stringify!(ZSTD_frameHeader))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_frameHeader>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_frameHeader))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).frameContentSize
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(frameContentSize)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).windowSize
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(windowSize)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).blockSizeMax
-                as *const _ as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(blockSizeMax)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).frameType as *const _
-                as usize
-        },
-        20usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(frameType)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).headerSize
-                as *const _ as usize
-        },
-        24usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(headerSize)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).dictID as *const _
-                as usize
-        },
-        28usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(dictID)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).checksumFlag
-                as *const _ as usize
-        },
-        32usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(checksumFlag)
-        )
-    );
-}
-extern "C" {
-    #[doc = " ZSTD_getFrameHeader() :"]
-    #[doc = "  decode Frame Header, or requires larger `srcSize`."]
-    #[doc = " @return : 0, `zfhPtr` is correctly filled,"]
-    #[doc = "          >0, `srcSize` is too small, value is wanted `srcSize` amount,"]
-    #[doc = "           or an error code, which can be tested using ZSTD_isError()"]
-    pub fn ZSTD_getFrameHeader(
-        zfhPtr: *mut ZSTD_frameHeader,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_getFrameHeader_advanced() :"]
-    #[doc = "  same as ZSTD_getFrameHeader(),"]
-    #[doc = "  with added capability to select a format (like ZSTD_f_zstd1_magicless)"]
-    pub fn ZSTD_getFrameHeader_advanced(
-        zfhPtr: *mut ZSTD_frameHeader,
-        src: *const libc::c_void,
-        srcSize: usize,
-        format: ZSTD_format_e,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decodingBufferSize_min(
-        windowSize: libc::c_ulonglong,
-        frameContentSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBegin(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBegin_usingDict(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBegin_usingDDict(
-        dctx: *mut ZSTD_DCtx,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_nextSrcSizeToDecompress(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressContinue(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_copyDCtx(dctx: *mut ZSTD_DCtx, preparedDCtx: *const ZSTD_DCtx);
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_nextInputType_e {
-    ZSTDnit_frameHeader = 0,
-    ZSTDnit_blockHeader = 1,
-    ZSTDnit_block = 2,
-    ZSTDnit_lastBlock = 3,
-    ZSTDnit_checksum = 4,
-    ZSTDnit_skippableFrame = 5,
-}
-extern "C" {
-    pub fn ZSTD_nextInputType(dctx: *mut ZSTD_DCtx) -> ZSTD_nextInputType_e;
-}
-extern "C" {
-    #[doc = "Block functions produce and decode raw zstd blocks, without frame metadata."]
-    #[doc = "Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes)."]
-    #[doc = "User will have to take in charge required information to regenerate data, such as compressed and content sizes."]
-    #[doc = ""]
-    #[doc = "A few rules to respect :"]
-    #[doc = "- Compressing and decompressing require a context structure"]
-    #[doc = "+ Use ZSTD_createCCtx() and ZSTD_createDCtx()"]
-    #[doc = "- It is necessary to init context before starting"]
-    #[doc = "+ compression : any ZSTD_compressBegin*() variant, including with dictionary"]
-    #[doc = "+ decompression : any ZSTD_decompressBegin*() variant, including with dictionary"]
-    #[doc = "+ copyCCtx() and copyDCtx() can be used too"]
-    #[doc = "- Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB"]
-    #[doc = "+ If input is larger than a block size, it\'s necessary to split input data into multiple blocks"]
-    #[doc = "+ For inputs larger than a single block, really consider using regular ZSTD_compress() instead."]
-    #[doc = "Frame metadata is not that costly, and quickly becomes negligible as source size grows larger."]
-    #[doc = "- When a block is considered not compressible enough, ZSTD_compressBlock() result will be zero."]
-    #[doc = "In which case, nothing is produced into `dst` !"]
-    #[doc = "+ User must test for such outcome and deal directly with uncompressed data"]
-    #[doc = "+ ZSTD_decompressBlock() doesn\'t accept uncompressed data as input !!!"]
-    #[doc = "+ In case of multiple successive blocks, should some of them be uncompressed,"]
-    #[doc = "decoder must be informed of their existence in order to follow proper history."]
-    #[doc = "Use ZSTD_insertBlock() for such a case."]
-    pub fn ZSTD_getBlockSize(cctx: *const ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBlock(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBlock(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_insertBlock(
-        dctx: *mut ZSTD_DCtx,
-        blockStart: *const libc::c_void,
-        blockSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZDICT_trainFromBuffer():"]
-    #[doc = "  Train a dictionary from an array of samples."]
-    #[doc = "  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,"]
-    #[doc = "  f=20, and accel=1."]
-    #[doc = "  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,"]
-    #[doc = "  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order."]
-    #[doc = "  The resulting dictionary will be saved into `dictBuffer`."]
-    #[doc = " @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)"]
-    #[doc = "          or an error code, which can be tested with ZDICT_isError()."]
-    #[doc = "  Note:  Dictionary training will fail if there are not enough samples to construct a"]
-    #[doc = "         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit)."]
-    #[doc = "         If dictionary training fails, you should use zstd without a dictionary, as the dictionary"]
-    #[doc = "         would\'ve been ineffective anyways. If you believe your samples would benefit from a dictionary"]
-    #[doc = "         please open an issue with details, and we can look into it."]
-    #[doc = "  Note: ZDICT_trainFromBuffer()\'s memory usage is about 6 MB."]
-    #[doc = "  Tips: In general, a reasonable dictionary has a size of ~ 100 KB."]
-    #[doc = "        It\'s possible to select smaller or larger size, just by specifying `dictBufferCapacity`."]
-    #[doc = "        In general, it\'s recommended to provide a few thousands samples, though this can vary a lot."]
-    #[doc = "        It\'s recommended that total size of all samples be about ~x100 times the target size of dictionary."]
-    pub fn ZDICT_trainFromBuffer(
-        dictBuffer: *mut libc::c_void,
-        dictBufferCapacity: usize,
-        samplesBuffer: *const libc::c_void,
-        samplesSizes: *const usize,
-        nbSamples: libc::c_uint,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZDICT_getDictID(
-        dictBuffer: *const libc::c_void,
-        dictSize: usize,
-    ) -> libc::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_isError(errorCode: usize) -> libc::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_getErrorName(errorCode: usize) -> *const libc::c_char;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTDMT_CCtx_s {
-    _unused: [u8; 0],
-}
-pub type ZSTDMT_CCtx = ZSTDMT_CCtx_s;
-extern "C" {
-    pub fn ZSTDMT_createCCtx(nbWorkers: libc::c_uint) -> *mut ZSTDMT_CCtx;
-}
-extern "C" {
-    pub fn ZSTDMT_createCCtx_advanced(
-        nbWorkers: libc::c_uint,
-        cMem: ZSTD_customMem,
-    ) -> *mut ZSTDMT_CCtx;
-}
-extern "C" {
-    pub fn ZSTDMT_freeCCtx(mtctx: *mut ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_sizeof_CCtx(mtctx: *mut ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_compressCCtx(
-        mtctx: *mut ZSTDMT_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_initCStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        compressionLevel: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_resetCStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_nextInputSizeHint(mtctx: *const ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_compressStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_flushStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_endStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_compress_advanced(
-        mtctx: *mut ZSTDMT_CCtx,
-        dst: *mut libc::c_void,
-        dstCapacity: usize,
-        src: *const libc::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-        params: ZSTD_parameters,
-        overlapLog: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_initCStream_advanced(
-        mtctx: *mut ZSTDMT_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_initCStream_usingCDict(
-        mtctx: *mut ZSTDMT_CCtx,
-        cdict: *const ZSTD_CDict,
-        fparams: ZSTD_frameParameters,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTDMT_parameter {
-    ZSTDMT_p_jobSize = 0,
-    ZSTDMT_p_overlapLog = 1,
-    ZSTDMT_p_rsyncable = 2,
-}
-extern "C" {
-    pub fn ZSTDMT_setMTCtxParameter(
-        mtctx: *mut ZSTDMT_CCtx,
-        parameter: ZSTDMT_parameter,
-        value: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_getMTCtxParameter(
-        mtctx: *mut ZSTDMT_CCtx,
-        parameter: ZSTDMT_parameter,
-        value: *mut libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_compressStream_generic() :"]
-    #[doc = "  Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream()"]
-    #[doc = "  depending on flush directive."]
-    #[doc = " @return : minimum amount of data still to be flushed"]
-    #[doc = "           0 if fully flushed"]
-    #[doc = "           or an error code"]
-    #[doc = "  note : needs to be init using any ZSTD_initCStream*() variant"]
-    pub fn ZSTDMT_compressStream_generic(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_toFlushNow()"]
-    #[doc = "  Tell how many bytes are ready to be flushed immediately."]
-    #[doc = "  Probe the oldest active job (not yet entirely flushed) and check its output buffer."]
-    #[doc = "  If return 0, it means there is no active job,"]
-    #[doc = "  or, it means oldest job is still active, but everything produced has been flushed so far,"]
-    #[doc = "  therefore flushing is limited by speed of oldest job."]
-    pub fn ZSTDMT_toFlushNow(mtctx: *mut ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_CCtxParam_setMTCtxParameter()"]
-    #[doc = "  like ZSTDMT_setMTCtxParameter(), but into a ZSTD_CCtx_Params"]
-    pub fn ZSTDMT_CCtxParam_setMTCtxParameter(
-        params: *mut ZSTD_CCtx_params,
-        parameter: ZSTDMT_parameter,
-        value: libc::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_CCtxParam_setNbWorkers()"]
-    #[doc = "  Set nbWorkers, and clamp it."]
-    #[doc = "  Also reset jobSize and overlapLog"]
-    pub fn ZSTDMT_CCtxParam_setNbWorkers(
-        params: *mut ZSTD_CCtx_params,
-        nbWorkers: libc::c_uint,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_updateCParams_whileCompressing() :"]
-    #[doc = "  Updates only a selected set of compression parameters, to remain compatible with current frame."]
-    #[doc = "  New parameters will be applied to next compression job."]
-    pub fn ZSTDMT_updateCParams_whileCompressing(
-        mtctx: *mut ZSTDMT_CCtx,
-        cctxParams: *const ZSTD_CCtx_params,
-    );
-}
-extern "C" {
-    #[doc = " ZSTDMT_getFrameProgression():"]
-    #[doc = "  tells how much data has been consumed (input) and produced (output) for current frame."]
-    #[doc = "  able to count progression inside worker threads."]
-    pub fn ZSTDMT_getFrameProgression(
-        mtctx: *mut ZSTDMT_CCtx,
-    ) -> ZSTD_frameProgression;
-}
-extern "C" {
-    #[doc = " ZSTDMT_initCStream_internal() :"]
-    #[doc = "  Private use only. Init streaming operation."]
-    #[doc = "  expects params to be valid."]
-    #[doc = "  must receive dict, or cdict, or none, but not both."]
-    #[doc = "  @return : 0, or an error code"]
-    pub fn ZSTDMT_initCStream_internal(
-        zcs: *mut ZSTDMT_CCtx,
-        dict: *const libc::c_void,
-        dictSize: usize,
-        dictContentType: ZSTD_dictContentType_e,
-        cdict: *const ZSTD_CDict,
-        params: ZSTD_CCtx_params,
-        pledgedSrcSize: libc::c_ulonglong,
-    ) -> usize;
-}
Index: zstd-sys-1/src/bindings_std.rs
===================================================================
--- zstd-sys-1.orig/src/bindings_std.rs
+++ /dev/null
@@ -1,943 +0,0 @@
-/* automatically generated by rust-bindgen */
-
-pub const ZSTD_VERSION_MAJOR: u32 = 1;
-pub const ZSTD_VERSION_MINOR: u32 = 4;
-pub const ZSTD_VERSION_RELEASE: u32 = 0;
-pub const ZSTD_VERSION_NUMBER: u32 = 10400;
-pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
-pub const ZSTD_MAGICNUMBER: u32 = 4247762216;
-pub const ZSTD_MAGIC_DICTIONARY: u32 = 3962610743;
-pub const ZSTD_MAGIC_SKIPPABLE_START: u32 = 407710288;
-pub const ZSTD_MAGIC_SKIPPABLE_MASK: u32 = 4294967280;
-pub const ZSTD_BLOCKSIZELOG_MAX: u32 = 17;
-pub const ZSTD_BLOCKSIZE_MAX: u32 = 131072;
-pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
-pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
-pub type wchar_t = ::std::os::raw::c_int;
-extern "C" {
-    pub fn ZSTD_versionNumber() -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_versionString() -> *const ::std::os::raw::c_char;
-}
-extern "C" {
-    #[doc = "  Simple API"]
-    #[doc = "  Compresses `src` content as a single zstd compressed frame into already allocated `dst`."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = "  @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "            or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress(
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress() :"]
-    #[doc = "  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames."]
-    #[doc = "  `dstCapacity` is an upper bound of originalSize to regenerate."]
-    #[doc = "  If user cannot imply a maximum upper bound, it\'s better to use streaming mode to decompress data."]
-    #[doc = "  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),"]
-    #[doc = "            or an errorCode if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_decompress(
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        compressedSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_getFrameContentSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_getDecompressedSize() :"]
-    #[doc = "  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize()."]
-    #[doc = "  Both functions work the same way, but ZSTD_getDecompressedSize() blends"]
-    #[doc = "  \"empty\", \"unknown\" and \"error\" results to the same return value (0),"]
-    #[doc = "  while ZSTD_getFrameContentSize() gives them separate return values."]
-    #[doc = " @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."]
-    pub fn ZSTD_getDecompressedSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_findFrameCompressedSize() :"]
-    #[doc = " `src` should point to the start of a ZSTD frame or skippable frame."]
-    #[doc = " `srcSize` must be >= first frame size"]
-    #[doc = " @return : the compressed size of the first frame starting at `src`,"]
-    #[doc = "           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,"]
-    #[doc = "        or an error code if input is invalid"]
-    pub fn ZSTD_findFrameCompressedSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_isError(code: usize) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_getErrorName(code: usize) -> *const ::std::os::raw::c_char;
-}
-extern "C" {
-    pub fn ZSTD_minCLevel() -> ::std::os::raw::c_int;
-}
-extern "C" {
-    pub fn ZSTD_maxCLevel() -> ::std::os::raw::c_int;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CCtx_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Explicit context"]
-pub type ZSTD_CCtx = ZSTD_CCtx_s;
-extern "C" {
-    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compressCCtx() :"]
-    #[doc = "  Same as ZSTD_compress(), using an explicit ZSTD_CCtx"]
-    #[doc = "  The function will compress at requested compression level,"]
-    #[doc = "  ignoring any other parameter"]
-    pub fn ZSTD_compressCCtx(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DCtx_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DCtx = ZSTD_DCtx_s;
-extern "C" {
-    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressDCtx() :"]
-    #[doc = "  Same as ZSTD_decompress(),"]
-    #[doc = "  requires an allocated ZSTD_DCtx."]
-    #[doc = "  Compatible with sticky parameters."]
-    pub fn ZSTD_decompressDCtx(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced compression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_strategy {
-    ZSTD_fast = 1,
-    ZSTD_dfast = 2,
-    ZSTD_greedy = 3,
-    ZSTD_lazy = 4,
-    ZSTD_lazy2 = 5,
-    ZSTD_btlazy2 = 6,
-    ZSTD_btopt = 7,
-    ZSTD_btultra = 8,
-    ZSTD_btultra2 = 9,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_cParameter {
-    ZSTD_c_compressionLevel = 100,
-    ZSTD_c_windowLog = 101,
-    ZSTD_c_hashLog = 102,
-    ZSTD_c_chainLog = 103,
-    ZSTD_c_searchLog = 104,
-    ZSTD_c_minMatch = 105,
-    ZSTD_c_targetLength = 106,
-    ZSTD_c_strategy = 107,
-    ZSTD_c_enableLongDistanceMatching = 160,
-    ZSTD_c_ldmHashLog = 161,
-    ZSTD_c_ldmMinMatch = 162,
-    ZSTD_c_ldmBucketSizeLog = 163,
-    ZSTD_c_ldmHashRateLog = 164,
-    ZSTD_c_contentSizeFlag = 200,
-    ZSTD_c_checksumFlag = 201,
-    ZSTD_c_dictIDFlag = 202,
-    ZSTD_c_nbWorkers = 400,
-    ZSTD_c_jobSize = 401,
-    ZSTD_c_overlapLog = 402,
-    ZSTD_c_experimentalParam1 = 500,
-    ZSTD_c_experimentalParam2 = 10,
-    ZSTD_c_experimentalParam3 = 1000,
-    ZSTD_c_experimentalParam4 = 1001,
-    ZSTD_c_experimentalParam5 = 1002,
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_bounds {
-    pub error: usize,
-    pub lowerBound: ::std::os::raw::c_int,
-    pub upperBound: ::std::os::raw::c_int,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_bounds() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_bounds>(),
-        16usize,
-        concat!("Size of: ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_bounds>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).error as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(error)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).lowerBound as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(lowerBound)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).upperBound as *const _
-                as usize
-        },
-        12usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(upperBound)
-        )
-    );
-}
-extern "C" {
-    #[doc = " ZSTD_cParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - lower and upper bounds, both inclusive"]
-    pub fn ZSTD_cParam_getBounds(cParam: ZSTD_cParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is generally only possible during frame initialization (before starting compression)."]
-    #[doc = "  Exception : when using multi-threading mode (nbWorkers >= 1),"]
-    #[doc = "              the following parameters can be updated _during_ compression (within same frame):"]
-    #[doc = "              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy."]
-    #[doc = "              new parameters will be active for next job only (after a flush())."]
-    #[doc = " @return : an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_CCtx_setParameter(
-        cctx: *mut ZSTD_CCtx,
-        param: ZSTD_cParameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setPledgedSrcSize() :"]
-    #[doc = "  Total input data size to be compressed as a single frame."]
-    #[doc = "  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag."]
-    #[doc = "  This value will also be controlled at end of frame, and trigger an error if not respected."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame."]
-    #[doc = "           In order to mean \"unknown content size\", pass constant ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame."]
-    #[doc = "  Note 2 : pledgedSrcSize is only valid once, for the next frame."]
-    #[doc = "           It\'s discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "  Note 3 : Whenever all input data is provided and consumed in a single round,"]
-    #[doc = "           for example with ZSTD_compress2(),"]
-    #[doc = "           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),"]
-    #[doc = "           this value is automatically overridden by srcSize instead."]
-    pub fn ZSTD_CCtx_setPledgedSrcSize(
-        cctx: *mut ZSTD_CCtx,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_ResetDirective {
-    ZSTD_reset_session_only = 1,
-    ZSTD_reset_parameters = 2,
-    ZSTD_reset_session_and_parameters = 3,
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_reset() :"]
-    #[doc = "  There are 2 different things that can be reset, independently or jointly :"]
-    #[doc = "  - The session : will stop compressing current frame, and make CCtx ready to start a new one."]
-    #[doc = "                  Useful after an error, or to interrupt any ongoing compression."]
-    #[doc = "                  Any internal data not yet flushed is cancelled."]
-    #[doc = "                  Compression parameters and dictionary remain unchanged."]
-    #[doc = "                  They will be used to compress next frame."]
-    #[doc = "                  Resetting session never fails."]
-    #[doc = "  - The parameters : changes all parameters back to \"default\"."]
-    #[doc = "                  This removes any reference to any dictionary too."]
-    #[doc = "                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)"]
-    #[doc = "                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())"]
-    #[doc = "  - Both : similar to resetting the session, followed by resetting parameters."]
-    pub fn ZSTD_CCtx_reset(
-        cctx: *mut ZSTD_CCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress2() :"]
-    #[doc = "  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API."]
-    #[doc = "  ZSTD_compress2() always starts a new frame."]
-    #[doc = "  Should cctx hold data from a previously unfinished frame, everything about it is forgotten."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - The function is always blocking, returns when compression is completed."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = " @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "           or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress2(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced decompression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dParameter {
-    ZSTD_d_windowLogMax = 100,
-    ZSTD_d_experimentalParam1 = 1000,
-}
-extern "C" {
-    #[doc = " ZSTD_dParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - both lower and upper bounds, inclusive"]
-    pub fn ZSTD_dParam_getBounds(dParam: ZSTD_dParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_dParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is only possible during frame initialization (before starting decompression)."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setParameter(
-        dctx: *mut ZSTD_DCtx,
-        param: ZSTD_dParameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_reset() :"]
-    #[doc = "  Return a DCtx to clean state."]
-    #[doc = "  Session and parameters can be reset jointly or separately."]
-    #[doc = "  Parameters can only be reset when no active frame is being decompressed."]
-    #[doc = " @return : 0, or an error code, which can be tested with ZSTD_isError()"]
-    pub fn ZSTD_DCtx_reset(
-        dctx: *mut ZSTD_DCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-#[doc = "  Streaming"]
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_inBuffer_s {
-    #[doc = "< start of input buffer"]
-    pub src: *const ::std::os::raw::c_void,
-    #[doc = "< size of input buffer"]
-    pub size: usize,
-    #[doc = "< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_inBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_inBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_inBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).src as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(src)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_outBuffer_s {
-    #[doc = "< start of output buffer"]
-    pub dst: *mut ::std::os::raw::c_void,
-    #[doc = "< size of output buffer"]
-    pub size: usize,
-    #[doc = "< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_outBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_outBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_outBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).dst as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(dst)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
-pub type ZSTD_CStream = ZSTD_CCtx;
-extern "C" {
-    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_EndDirective {
-    ZSTD_e_continue = 0,
-    ZSTD_e_flush = 1,
-    ZSTD_e_end = 2,
-}
-extern "C" {
-    #[doc = " ZSTD_compressStream2() :"]
-    #[doc = "  Behaves about the same as ZSTD_compressStream, with additional control on end directive."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)"]
-    #[doc = "  - output->pos must be <= dstCapacity, input->pos must be <= srcSize"]
-    #[doc = "  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit."]
-    #[doc = "  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller."]
-    #[doc = "  - When nbWorkers>=1, function is non-blocking : it just acquires a copy of input, and distributes jobs to internal worker threads, flush whatever is available,"]
-    #[doc = "                                                  and then immediately returns, just indicating that there is some data remaining to be flushed."]
-    #[doc = "                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte."]
-    #[doc = "  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking."]
-    #[doc = "  - @return provides a minimum amount of data remaining to be flushed from internal buffers"]
-    #[doc = "            or an error code, which can be tested using ZSTD_isError()."]
-    #[doc = "            if @return != 0, flush is not fully completed, there is still some data left within internal buffers."]
-    #[doc = "            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers."]
-    #[doc = "            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed."]
-    #[doc = "  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),"]
-    #[doc = "            only ZSTD_e_end or ZSTD_e_flush operations are allowed."]
-    #[doc = "            Before starting a new compression job, or changing compression parameters,"]
-    #[doc = "            it is required to fully flush internal buffers."]
-    pub fn ZSTD_compressStream2(
-        cctx: *mut ZSTD_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    pub fn ZSTD_initCStream(
-        zcs: *mut ZSTD_CStream,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue)."]
-    #[doc = " NOTE: The return value is different. ZSTD_compressStream() returns a hint for"]
-    #[doc = " the next read size (if non-zero and not an error). ZSTD_compressStream2()"]
-    #[doc = " returns the number of bytes left to flush (if non-zero and not an error)."]
-    pub fn ZSTD_compressStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush)."]
-    pub fn ZSTD_flushStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end)."]
-    pub fn ZSTD_endStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-pub type ZSTD_DStream = ZSTD_DCtx;
-extern "C" {
-    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressStream(
-        zds: *mut ZSTD_DStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = "  Simple dictionary API"]
-    #[doc = "  Compression at an explicit compression level using a Dictionary."]
-    #[doc = "  A dictionary can be any arbitrary data segment (also called a prefix),"]
-    #[doc = "  or a buffer with specified information (see dictBuilder/zdict.h)."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_compress_usingDict(
-        ctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDict() :"]
-    #[doc = "  Decompression using a known Dictionary."]
-    #[doc = "  Dictionary must be identical to the one used during compression."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_decompress_usingDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CDict_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Bulk processing dictionary API"]
-pub type ZSTD_CDict = ZSTD_CDict_s;
-extern "C" {
-    #[doc = " ZSTD_createCDict() :"]
-    #[doc = "  When compressing multiple messages / blocks using the same dictionary, it\'s recommended to load it only once."]
-    #[doc = "  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup cost."]
-    #[doc = "  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only."]
-    #[doc = " `dictBuffer` can be released after ZSTD_CDict creation, because its content is copied within CDict."]
-    #[doc = "  Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate `dictBuffer` content."]
-    #[doc = "  Note : A ZSTD_CDict can be created from an empty dictBuffer, but it is inefficient when used to compress small data."]
-    pub fn ZSTD_createCDict(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeCDict() :"]
-    #[doc = "  Function frees memory allocated by ZSTD_createCDict()."]
-    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_usingCDict() :"]
-    #[doc = "  Compression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    #[doc = "  Note : compression level is _decided at dictionary creation time_,"]
-    #[doc = "     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"]
-    pub fn ZSTD_compress_usingCDict(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DDict_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DDict = ZSTD_DDict_s;
-extern "C" {
-    #[doc = " ZSTD_createDDict() :"]
-    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
-    #[doc = "  dictBuffer can be released after DDict creation, as its content is copied inside DDict."]
-    pub fn ZSTD_createDDict(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeDDict() :"]
-    #[doc = "  Function frees memory allocated with ZSTD_createDDict()"]
-    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDDict() :"]
-    #[doc = "  Decompression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    pub fn ZSTD_decompress_usingDDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDict() :"]
-    #[doc = "  Provides the dictID stored within dictionary."]
-    #[doc = "  if @return == 0, the dictionary is not conformant with Zstandard specification."]
-    #[doc = "  It can still be loaded, but as a content-only dictionary."]
-    pub fn ZSTD_getDictID_fromDict(
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDDict() :"]
-    #[doc = "  Provides the dictID of the dictionary loaded into `ddict`."]
-    #[doc = "  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty."]
-    #[doc = "  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."]
-    pub fn ZSTD_getDictID_fromDDict(
-        ddict: *const ZSTD_DDict,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromFrame() :"]
-    #[doc = "  Provides the dictID required to decompressed the frame stored within `src`."]
-    #[doc = "  If @return == 0, the dictID could not be decoded."]
-    #[doc = "  This could for one of the following reasons :"]
-    #[doc = "  - The frame does not require a dictionary to be decoded (most common case)."]
-    #[doc = "  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information."]
-    #[doc = "    Note : this use case also happens when using a non-conformant dictionary."]
-    #[doc = "  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`)."]
-    #[doc = "  - This is not a Zstandard frame."]
-    #[doc = "  When identifying the exact failure cause, it\'s possible to use ZSTD_getFrameHeader(), which will provide a more precise error code."]
-    pub fn ZSTD_getDictID_fromFrame(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary() :"]
-    #[doc = "  Create an internal CDict from `dict` buffer."]
-    #[doc = "  Decompression will have to use same dictionary."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,"]
-    #[doc = "           meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Dictionary is sticky, it will be used for all future compressed frames."]
-    #[doc = "           To return to \"no-dictionary\" situation, load a NULL dictionary (or reset parameters)."]
-    #[doc = "  Note 2 : Loading a dictionary involves building tables."]
-    #[doc = "           It\'s also a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           Tables are dependent on compression parameters, and for this reason,"]
-    #[doc = "           compression parameters can no longer be changed after loading a dictionary."]
-    #[doc = "  Note 3 :`dict` content will be copied internally."]
-    #[doc = "           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead."]
-    #[doc = "           In such a case, dictionary buffer must outlive its users."]
-    #[doc = "  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()"]
-    #[doc = "           to precisely select how dictionary content must be interpreted."]
-    pub fn ZSTD_CCtx_loadDictionary(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refCDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used for all next compressed frames."]
-    #[doc = "  Note that compression parameters are enforced from within CDict,"]
-    #[doc = "  and supersede any compression parameter previously set within CCtx."]
-    #[doc = "  The parameters ignored are labled as \"superseded-by-cdict\" in the ZSTD_cParameter enum docs."]
-    #[doc = "  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode."]
-    #[doc = "  The dictionary will remain valid for future compressed frames using same CCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Referencing a NULL CDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx."]
-    pub fn ZSTD_CCtx_refCDict(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) for next compressed frame."]
-    #[doc = "  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end)."]
-    #[doc = "  Decompression will need same prefix to properly regenerate data."]
-    #[doc = "  Compressing with a prefix is similar in outcome as performing a diff and compressing it,"]
-    #[doc = "  but performs much faster, especially during decompression (compression speed is tunable with compression level)."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary"]
-    #[doc = "  Note 1 : Prefix buffer is referenced. It **must** outlive compression."]
-    #[doc = "           Its content must remain unmodified during compression."]
-    #[doc = "  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,"]
-    #[doc = "           ensure that the window size is large enough to contain the entire source."]
-    #[doc = "           See ZSTD_c_windowLog."]
-    #[doc = "  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters."]
-    #[doc = "           It\'s a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           If there is a need to use the same prefix multiple times, consider loadDictionary instead."]
-    #[doc = "  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation."]
-    pub fn ZSTD_CCtx_refPrefix(
-        cctx: *mut ZSTD_CCtx,
-        prefix: *const ::std::os::raw::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary() :"]
-    #[doc = "  Create an internal DDict from dict buffer,"]
-    #[doc = "  to be used to decompress next frames."]
-    #[doc = "  The dictionary remains valid for all future frames, until explicitly invalidated."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,"]
-    #[doc = "            meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Loading a dictionary involves building tables,"]
-    #[doc = "           which has a non-negligible impact on CPU usage and latency."]
-    #[doc = "           It\'s recommended to \"load once, use many times\", to amortize the cost"]
-    #[doc = "  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading."]
-    #[doc = "           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead."]
-    #[doc = "  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of"]
-    #[doc = "           how dictionary content is loaded and interpreted."]
-    pub fn ZSTD_DCtx_loadDictionary(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refDDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used to decompress next frames."]
-    #[doc = "  The dictionary remains active for decompression of future frames using same DCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Special: referencing a NULL DDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."]
-    pub fn ZSTD_DCtx_refDDict(
-        dctx: *mut ZSTD_DCtx,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) to decompress next frame."]
-    #[doc = "  This is the reverse operation of ZSTD_CCtx_refPrefix(),"]
-    #[doc = "  and must use the same prefix as the one used during compression."]
-    #[doc = "  Prefix is **only used once**. Reference is discarded at end of frame."]
-    #[doc = "  End of frame is reached when ZSTD_decompressStream() returns 0."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary"]
-    #[doc = "  Note 2 : Prefix buffer is referenced. It **must** outlive decompression."]
-    #[doc = "           Prefix buffer must remain unmodified up to the end of frame,"]
-    #[doc = "           reached when ZSTD_decompressStream() returns 0."]
-    #[doc = "  Note 3 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)"]
-    #[doc = "  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost."]
-    #[doc = "           A full dictionary is more costly, as it requires building tables."]
-    pub fn ZSTD_DCtx_refPrefix(
-        dctx: *mut ZSTD_DCtx,
-        prefix: *const ::std::os::raw::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_sizeof_*() :"]
-    #[doc = "  These functions give the _current_ memory usage of selected object."]
-    #[doc = "  Note that object memory usage can evolve (increase or decrease) over time."]
-    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZDICT_trainFromBuffer():"]
-    #[doc = "  Train a dictionary from an array of samples."]
-    #[doc = "  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,"]
-    #[doc = "  f=20, and accel=1."]
-    #[doc = "  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,"]
-    #[doc = "  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order."]
-    #[doc = "  The resulting dictionary will be saved into `dictBuffer`."]
-    #[doc = " @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)"]
-    #[doc = "          or an error code, which can be tested with ZDICT_isError()."]
-    #[doc = "  Note:  Dictionary training will fail if there are not enough samples to construct a"]
-    #[doc = "         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit)."]
-    #[doc = "         If dictionary training fails, you should use zstd without a dictionary, as the dictionary"]
-    #[doc = "         would\'ve been ineffective anyways. If you believe your samples would benefit from a dictionary"]
-    #[doc = "         please open an issue with details, and we can look into it."]
-    #[doc = "  Note: ZDICT_trainFromBuffer()\'s memory usage is about 6 MB."]
-    #[doc = "  Tips: In general, a reasonable dictionary has a size of ~ 100 KB."]
-    #[doc = "        It\'s possible to select smaller or larger size, just by specifying `dictBufferCapacity`."]
-    #[doc = "        In general, it\'s recommended to provide a few thousands samples, though this can vary a lot."]
-    #[doc = "        It\'s recommended that total size of all samples be about ~x100 times the target size of dictionary."]
-    pub fn ZDICT_trainFromBuffer(
-        dictBuffer: *mut ::std::os::raw::c_void,
-        dictBufferCapacity: usize,
-        samplesBuffer: *const ::std::os::raw::c_void,
-        samplesSizes: *const usize,
-        nbSamples: ::std::os::raw::c_uint,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZDICT_getDictID(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_isError(errorCode: usize) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_getErrorName(
-        errorCode: usize,
-    ) -> *const ::std::os::raw::c_char;
-}
Index: zstd-sys-1/src/bindings_std_experimental.rs
===================================================================
--- zstd-sys-1.orig/src/bindings_std_experimental.rs
+++ /dev/null
@@ -1,2671 +0,0 @@
-/* automatically generated by rust-bindgen */
-
-pub const ZSTD_VERSION_MAJOR: u32 = 1;
-pub const ZSTD_VERSION_MINOR: u32 = 4;
-pub const ZSTD_VERSION_RELEASE: u32 = 0;
-pub const ZSTD_VERSION_NUMBER: u32 = 10400;
-pub const ZSTD_CLEVEL_DEFAULT: u32 = 3;
-pub const ZSTD_MAGICNUMBER: u32 = 4247762216;
-pub const ZSTD_MAGIC_DICTIONARY: u32 = 3962610743;
-pub const ZSTD_MAGIC_SKIPPABLE_START: u32 = 407710288;
-pub const ZSTD_MAGIC_SKIPPABLE_MASK: u32 = 4294967280;
-pub const ZSTD_BLOCKSIZELOG_MAX: u32 = 17;
-pub const ZSTD_BLOCKSIZE_MAX: u32 = 131072;
-pub const ZSTD_CONTENTSIZE_UNKNOWN: i32 = -1;
-pub const ZSTD_CONTENTSIZE_ERROR: i32 = -2;
-pub const ZSTD_FRAMEHEADERSIZE_PREFIX: u32 = 5;
-pub const ZSTD_FRAMEHEADERSIZE_MIN: u32 = 6;
-pub const ZSTD_FRAMEHEADERSIZE_MAX: u32 = 18;
-pub const ZSTD_SKIPPABLEHEADERSIZE: u32 = 8;
-pub const ZSTD_WINDOWLOG_MAX_32: u32 = 30;
-pub const ZSTD_WINDOWLOG_MAX_64: u32 = 31;
-pub const ZSTD_WINDOWLOG_MIN: u32 = 10;
-pub const ZSTD_HASHLOG_MIN: u32 = 6;
-pub const ZSTD_CHAINLOG_MAX_32: u32 = 29;
-pub const ZSTD_CHAINLOG_MAX_64: u32 = 30;
-pub const ZSTD_CHAINLOG_MIN: u32 = 6;
-pub const ZSTD_SEARCHLOG_MIN: u32 = 1;
-pub const ZSTD_MINMATCH_MAX: u32 = 7;
-pub const ZSTD_MINMATCH_MIN: u32 = 3;
-pub const ZSTD_TARGETLENGTH_MAX: u32 = 131072;
-pub const ZSTD_TARGETLENGTH_MIN: u32 = 0;
-pub const ZSTD_OVERLAPLOG_MIN: u32 = 0;
-pub const ZSTD_OVERLAPLOG_MAX: u32 = 9;
-pub const ZSTD_WINDOWLOG_LIMIT_DEFAULT: u32 = 27;
-pub const ZSTD_LDM_HASHLOG_MIN: u32 = 6;
-pub const ZSTD_LDM_MINMATCH_MIN: u32 = 4;
-pub const ZSTD_LDM_MINMATCH_MAX: u32 = 4096;
-pub const ZSTD_LDM_BUCKETSIZELOG_MIN: u32 = 1;
-pub const ZSTD_LDM_BUCKETSIZELOG_MAX: u32 = 8;
-pub const ZSTD_LDM_HASHRATELOG_MIN: u32 = 0;
-pub const ZSTD_HASHLOG3_MAX: u32 = 17;
-pub const ZSTDMT_NBWORKERS_MAX: u32 = 200;
-pub type wchar_t = ::std::os::raw::c_int;
-extern "C" {
-    pub fn ZSTD_versionNumber() -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_versionString() -> *const ::std::os::raw::c_char;
-}
-extern "C" {
-    #[doc = "  Simple API"]
-    #[doc = "  Compresses `src` content as a single zstd compressed frame into already allocated `dst`."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = "  @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "            or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress(
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress() :"]
-    #[doc = "  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames."]
-    #[doc = "  `dstCapacity` is an upper bound of originalSize to regenerate."]
-    #[doc = "  If user cannot imply a maximum upper bound, it\'s better to use streaming mode to decompress data."]
-    #[doc = "  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),"]
-    #[doc = "            or an errorCode if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_decompress(
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        compressedSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_getFrameContentSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_getDecompressedSize() :"]
-    #[doc = "  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize()."]
-    #[doc = "  Both functions work the same way, but ZSTD_getDecompressedSize() blends"]
-    #[doc = "  \"empty\", \"unknown\" and \"error\" results to the same return value (0),"]
-    #[doc = "  while ZSTD_getFrameContentSize() gives them separate return values."]
-    #[doc = " @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."]
-    pub fn ZSTD_getDecompressedSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_findFrameCompressedSize() :"]
-    #[doc = " `src` should point to the start of a ZSTD frame or skippable frame."]
-    #[doc = " `srcSize` must be >= first frame size"]
-    #[doc = " @return : the compressed size of the first frame starting at `src`,"]
-    #[doc = "           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,"]
-    #[doc = "        or an error code if input is invalid"]
-    pub fn ZSTD_findFrameCompressedSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBound(srcSize: usize) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_isError(code: usize) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZSTD_getErrorName(code: usize) -> *const ::std::os::raw::c_char;
-}
-extern "C" {
-    pub fn ZSTD_minCLevel() -> ::std::os::raw::c_int;
-}
-extern "C" {
-    pub fn ZSTD_maxCLevel() -> ::std::os::raw::c_int;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CCtx_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Explicit context"]
-pub type ZSTD_CCtx = ZSTD_CCtx_s;
-extern "C" {
-    pub fn ZSTD_createCCtx() -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeCCtx(cctx: *mut ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compressCCtx() :"]
-    #[doc = "  Same as ZSTD_compress(), using an explicit ZSTD_CCtx"]
-    #[doc = "  The function will compress at requested compression level,"]
-    #[doc = "  ignoring any other parameter"]
-    pub fn ZSTD_compressCCtx(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DCtx_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DCtx = ZSTD_DCtx_s;
-extern "C" {
-    pub fn ZSTD_createDCtx() -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_freeDCtx(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressDCtx() :"]
-    #[doc = "  Same as ZSTD_decompress(),"]
-    #[doc = "  requires an allocated ZSTD_DCtx."]
-    #[doc = "  Compatible with sticky parameters."]
-    pub fn ZSTD_decompressDCtx(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced compression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_strategy {
-    ZSTD_fast = 1,
-    ZSTD_dfast = 2,
-    ZSTD_greedy = 3,
-    ZSTD_lazy = 4,
-    ZSTD_lazy2 = 5,
-    ZSTD_btlazy2 = 6,
-    ZSTD_btopt = 7,
-    ZSTD_btultra = 8,
-    ZSTD_btultra2 = 9,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_cParameter {
-    ZSTD_c_compressionLevel = 100,
-    ZSTD_c_windowLog = 101,
-    ZSTD_c_hashLog = 102,
-    ZSTD_c_chainLog = 103,
-    ZSTD_c_searchLog = 104,
-    ZSTD_c_minMatch = 105,
-    ZSTD_c_targetLength = 106,
-    ZSTD_c_strategy = 107,
-    ZSTD_c_enableLongDistanceMatching = 160,
-    ZSTD_c_ldmHashLog = 161,
-    ZSTD_c_ldmMinMatch = 162,
-    ZSTD_c_ldmBucketSizeLog = 163,
-    ZSTD_c_ldmHashRateLog = 164,
-    ZSTD_c_contentSizeFlag = 200,
-    ZSTD_c_checksumFlag = 201,
-    ZSTD_c_dictIDFlag = 202,
-    ZSTD_c_nbWorkers = 400,
-    ZSTD_c_jobSize = 401,
-    ZSTD_c_overlapLog = 402,
-    ZSTD_c_experimentalParam1 = 500,
-    ZSTD_c_experimentalParam2 = 10,
-    ZSTD_c_experimentalParam3 = 1000,
-    ZSTD_c_experimentalParam4 = 1001,
-    ZSTD_c_experimentalParam5 = 1002,
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_bounds {
-    pub error: usize,
-    pub lowerBound: ::std::os::raw::c_int,
-    pub upperBound: ::std::os::raw::c_int,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_bounds() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_bounds>(),
-        16usize,
-        concat!("Size of: ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_bounds>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_bounds))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).error as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(error)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).lowerBound as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(lowerBound)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_bounds>())).upperBound as *const _
-                as usize
-        },
-        12usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_bounds),
-            "::",
-            stringify!(upperBound)
-        )
-    );
-}
-extern "C" {
-    #[doc = " ZSTD_cParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - lower and upper bounds, both inclusive"]
-    pub fn ZSTD_cParam_getBounds(cParam: ZSTD_cParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is generally only possible during frame initialization (before starting compression)."]
-    #[doc = "  Exception : when using multi-threading mode (nbWorkers >= 1),"]
-    #[doc = "              the following parameters can be updated _during_ compression (within same frame):"]
-    #[doc = "              => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy."]
-    #[doc = "              new parameters will be active for next job only (after a flush())."]
-    #[doc = " @return : an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_CCtx_setParameter(
-        cctx: *mut ZSTD_CCtx,
-        param: ZSTD_cParameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setPledgedSrcSize() :"]
-    #[doc = "  Total input data size to be compressed as a single frame."]
-    #[doc = "  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag."]
-    #[doc = "  This value will also be controlled at end of frame, and trigger an error if not respected."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame."]
-    #[doc = "           In order to mean \"unknown content size\", pass constant ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame."]
-    #[doc = "  Note 2 : pledgedSrcSize is only valid once, for the next frame."]
-    #[doc = "           It\'s discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "  Note 3 : Whenever all input data is provided and consumed in a single round,"]
-    #[doc = "           for example with ZSTD_compress2(),"]
-    #[doc = "           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),"]
-    #[doc = "           this value is automatically overridden by srcSize instead."]
-    pub fn ZSTD_CCtx_setPledgedSrcSize(
-        cctx: *mut ZSTD_CCtx,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_ResetDirective {
-    ZSTD_reset_session_only = 1,
-    ZSTD_reset_parameters = 2,
-    ZSTD_reset_session_and_parameters = 3,
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_reset() :"]
-    #[doc = "  There are 2 different things that can be reset, independently or jointly :"]
-    #[doc = "  - The session : will stop compressing current frame, and make CCtx ready to start a new one."]
-    #[doc = "                  Useful after an error, or to interrupt any ongoing compression."]
-    #[doc = "                  Any internal data not yet flushed is cancelled."]
-    #[doc = "                  Compression parameters and dictionary remain unchanged."]
-    #[doc = "                  They will be used to compress next frame."]
-    #[doc = "                  Resetting session never fails."]
-    #[doc = "  - The parameters : changes all parameters back to \"default\"."]
-    #[doc = "                  This removes any reference to any dictionary too."]
-    #[doc = "                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)"]
-    #[doc = "                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())"]
-    #[doc = "  - Both : similar to resetting the session, followed by resetting parameters."]
-    pub fn ZSTD_CCtx_reset(
-        cctx: *mut ZSTD_CCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress2() :"]
-    #[doc = "  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API."]
-    #[doc = "  ZSTD_compress2() always starts a new frame."]
-    #[doc = "  Should cctx hold data from a previously unfinished frame, everything about it is forgotten."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - The function is always blocking, returns when compression is completed."]
-    #[doc = "  Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`."]
-    #[doc = " @return : compressed size written into `dst` (<= `dstCapacity),"]
-    #[doc = "           or an error code if it fails (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_compress2(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[doc = "  Advanced decompression API"]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dParameter {
-    ZSTD_d_windowLogMax = 100,
-    ZSTD_d_experimentalParam1 = 1000,
-}
-extern "C" {
-    #[doc = " ZSTD_dParam_getBounds() :"]
-    #[doc = "  All parameters must belong to an interval with lower and upper bounds,"]
-    #[doc = "  otherwise they will either trigger an error or be automatically clamped."]
-    #[doc = " @return : a structure, ZSTD_bounds, which contains"]
-    #[doc = "         - an error status field, which must be tested using ZSTD_isError()"]
-    #[doc = "         - both lower and upper bounds, inclusive"]
-    pub fn ZSTD_dParam_getBounds(dParam: ZSTD_dParameter) -> ZSTD_bounds;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setParameter() :"]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_dParameter."]
-    #[doc = "  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds()."]
-    #[doc = "  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter)."]
-    #[doc = "  Setting a parameter is only possible during frame initialization (before starting decompression)."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setParameter(
-        dctx: *mut ZSTD_DCtx,
-        param: ZSTD_dParameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_reset() :"]
-    #[doc = "  Return a DCtx to clean state."]
-    #[doc = "  Session and parameters can be reset jointly or separately."]
-    #[doc = "  Parameters can only be reset when no active frame is being decompressed."]
-    #[doc = " @return : 0, or an error code, which can be tested with ZSTD_isError()"]
-    pub fn ZSTD_DCtx_reset(
-        dctx: *mut ZSTD_DCtx,
-        reset: ZSTD_ResetDirective,
-    ) -> usize;
-}
-#[doc = "  Streaming"]
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_inBuffer_s {
-    #[doc = "< start of input buffer"]
-    pub src: *const ::std::os::raw::c_void,
-    #[doc = "< size of input buffer"]
-    pub size: usize,
-    #[doc = "< position where reading stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_inBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_inBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_inBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_inBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).src as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(src)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_inBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_inBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_inBuffer = ZSTD_inBuffer_s;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_outBuffer_s {
-    #[doc = "< start of output buffer"]
-    pub dst: *mut ::std::os::raw::c_void,
-    #[doc = "< size of output buffer"]
-    pub size: usize,
-    #[doc = "< position where writing stopped. Will be updated. Necessarily 0 <= pos <= size"]
-    pub pos: usize,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_outBuffer_s() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_outBuffer_s>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_outBuffer_s>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_outBuffer_s))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).dst as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(dst)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).size as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(size)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_outBuffer_s>())).pos as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_outBuffer_s),
-            "::",
-            stringify!(pos)
-        )
-    );
-}
-pub type ZSTD_outBuffer = ZSTD_outBuffer_s;
-pub type ZSTD_CStream = ZSTD_CCtx;
-extern "C" {
-    pub fn ZSTD_createCStream() -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_freeCStream(zcs: *mut ZSTD_CStream) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_EndDirective {
-    ZSTD_e_continue = 0,
-    ZSTD_e_flush = 1,
-    ZSTD_e_end = 2,
-}
-extern "C" {
-    #[doc = " ZSTD_compressStream2() :"]
-    #[doc = "  Behaves about the same as ZSTD_compressStream, with additional control on end directive."]
-    #[doc = "  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()"]
-    #[doc = "  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)"]
-    #[doc = "  - output->pos must be <= dstCapacity, input->pos must be <= srcSize"]
-    #[doc = "  - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit."]
-    #[doc = "  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller."]
-    #[doc = "  - When nbWorkers>=1, function is non-blocking : it just acquires a copy of input, and distributes jobs to internal worker threads, flush whatever is available,"]
-    #[doc = "                                                  and then immediately returns, just indicating that there is some data remaining to be flushed."]
-    #[doc = "                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte."]
-    #[doc = "  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking."]
-    #[doc = "  - @return provides a minimum amount of data remaining to be flushed from internal buffers"]
-    #[doc = "            or an error code, which can be tested using ZSTD_isError()."]
-    #[doc = "            if @return != 0, flush is not fully completed, there is still some data left within internal buffers."]
-    #[doc = "            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers."]
-    #[doc = "            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed."]
-    #[doc = "  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),"]
-    #[doc = "            only ZSTD_e_end or ZSTD_e_flush operations are allowed."]
-    #[doc = "            Before starting a new compression job, or changing compression parameters,"]
-    #[doc = "            it is required to fully flush internal buffers."]
-    pub fn ZSTD_compressStream2(
-        cctx: *mut ZSTD_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_CStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    pub fn ZSTD_initCStream(
-        zcs: *mut ZSTD_CStream,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue)."]
-    #[doc = " NOTE: The return value is different. ZSTD_compressStream() returns a hint for"]
-    #[doc = " the next read size (if non-zero and not an error). ZSTD_compressStream2()"]
-    #[doc = " returns the number of bytes left to flush (if non-zero and not an error)."]
-    pub fn ZSTD_compressStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush)."]
-    pub fn ZSTD_flushStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end)."]
-    pub fn ZSTD_endStream(
-        zcs: *mut ZSTD_CStream,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-pub type ZSTD_DStream = ZSTD_DCtx;
-extern "C" {
-    pub fn ZSTD_createDStream() -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_freeDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_initDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressStream(
-        zds: *mut ZSTD_DStream,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamInSize() -> usize;
-}
-extern "C" {
-    pub fn ZSTD_DStreamOutSize() -> usize;
-}
-extern "C" {
-    #[doc = "  Simple dictionary API"]
-    #[doc = "  Compression at an explicit compression level using a Dictionary."]
-    #[doc = "  A dictionary can be any arbitrary data segment (also called a prefix),"]
-    #[doc = "  or a buffer with specified information (see dictBuilder/zdict.h)."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_compress_usingDict(
-        ctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDict() :"]
-    #[doc = "  Decompression using a known Dictionary."]
-    #[doc = "  Dictionary must be identical to the one used during compression."]
-    #[doc = "  Note : This function loads the dictionary, resulting in significant startup delay."]
-    #[doc = "         It\'s intended for a dictionary used only once."]
-    #[doc = "  Note : When `dict == NULL || dictSize < 8` no dictionary is used."]
-    pub fn ZSTD_decompress_usingDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CDict_s {
-    _unused: [u8; 0],
-}
-#[doc = "  Bulk processing dictionary API"]
-pub type ZSTD_CDict = ZSTD_CDict_s;
-extern "C" {
-    #[doc = " ZSTD_createCDict() :"]
-    #[doc = "  When compressing multiple messages / blocks using the same dictionary, it\'s recommended to load it only once."]
-    #[doc = "  ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup cost."]
-    #[doc = "  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only."]
-    #[doc = " `dictBuffer` can be released after ZSTD_CDict creation, because its content is copied within CDict."]
-    #[doc = "  Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate `dictBuffer` content."]
-    #[doc = "  Note : A ZSTD_CDict can be created from an empty dictBuffer, but it is inefficient when used to compress small data."]
-    pub fn ZSTD_createCDict(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeCDict() :"]
-    #[doc = "  Function frees memory allocated by ZSTD_createCDict()."]
-    pub fn ZSTD_freeCDict(CDict: *mut ZSTD_CDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_usingCDict() :"]
-    #[doc = "  Compression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    #[doc = "  Note : compression level is _decided at dictionary creation time_,"]
-    #[doc = "     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"]
-    pub fn ZSTD_compress_usingCDict(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_DDict_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_DDict = ZSTD_DDict_s;
-extern "C" {
-    #[doc = " ZSTD_createDDict() :"]
-    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
-    #[doc = "  dictBuffer can be released after DDict creation, as its content is copied inside DDict."]
-    pub fn ZSTD_createDDict(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_freeDDict() :"]
-    #[doc = "  Function frees memory allocated with ZSTD_createDDict()"]
-    pub fn ZSTD_freeDDict(ddict: *mut ZSTD_DDict) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompress_usingDDict() :"]
-    #[doc = "  Decompression using a digested Dictionary."]
-    #[doc = "  Recommended when same dictionary is used multiple times."]
-    pub fn ZSTD_decompress_usingDDict(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDict() :"]
-    #[doc = "  Provides the dictID stored within dictionary."]
-    #[doc = "  if @return == 0, the dictionary is not conformant with Zstandard specification."]
-    #[doc = "  It can still be loaded, but as a content-only dictionary."]
-    pub fn ZSTD_getDictID_fromDict(
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromDDict() :"]
-    #[doc = "  Provides the dictID of the dictionary loaded into `ddict`."]
-    #[doc = "  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty."]
-    #[doc = "  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."]
-    pub fn ZSTD_getDictID_fromDDict(
-        ddict: *const ZSTD_DDict,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_getDictID_fromFrame() :"]
-    #[doc = "  Provides the dictID required to decompressed the frame stored within `src`."]
-    #[doc = "  If @return == 0, the dictID could not be decoded."]
-    #[doc = "  This could for one of the following reasons :"]
-    #[doc = "  - The frame does not require a dictionary to be decoded (most common case)."]
-    #[doc = "  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information."]
-    #[doc = "    Note : this use case also happens when using a non-conformant dictionary."]
-    #[doc = "  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`)."]
-    #[doc = "  - This is not a Zstandard frame."]
-    #[doc = "  When identifying the exact failure cause, it\'s possible to use ZSTD_getFrameHeader(), which will provide a more precise error code."]
-    pub fn ZSTD_getDictID_fromFrame(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary() :"]
-    #[doc = "  Create an internal CDict from `dict` buffer."]
-    #[doc = "  Decompression will have to use same dictionary."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,"]
-    #[doc = "           meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Dictionary is sticky, it will be used for all future compressed frames."]
-    #[doc = "           To return to \"no-dictionary\" situation, load a NULL dictionary (or reset parameters)."]
-    #[doc = "  Note 2 : Loading a dictionary involves building tables."]
-    #[doc = "           It\'s also a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           Tables are dependent on compression parameters, and for this reason,"]
-    #[doc = "           compression parameters can no longer be changed after loading a dictionary."]
-    #[doc = "  Note 3 :`dict` content will be copied internally."]
-    #[doc = "           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead."]
-    #[doc = "           In such a case, dictionary buffer must outlive its users."]
-    #[doc = "  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()"]
-    #[doc = "           to precisely select how dictionary content must be interpreted."]
-    pub fn ZSTD_CCtx_loadDictionary(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refCDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used for all next compressed frames."]
-    #[doc = "  Note that compression parameters are enforced from within CDict,"]
-    #[doc = "  and supersede any compression parameter previously set within CCtx."]
-    #[doc = "  The parameters ignored are labled as \"superseded-by-cdict\" in the ZSTD_cParameter enum docs."]
-    #[doc = "  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode."]
-    #[doc = "  The dictionary will remain valid for future compressed frames using same CCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Referencing a NULL CDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx."]
-    pub fn ZSTD_CCtx_refCDict(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) for next compressed frame."]
-    #[doc = "  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end)."]
-    #[doc = "  Decompression will need same prefix to properly regenerate data."]
-    #[doc = "  Compressing with a prefix is similar in outcome as performing a diff and compressing it,"]
-    #[doc = "  but performs much faster, especially during decompression (compression speed is tunable with compression level)."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary"]
-    #[doc = "  Note 1 : Prefix buffer is referenced. It **must** outlive compression."]
-    #[doc = "           Its content must remain unmodified during compression."]
-    #[doc = "  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,"]
-    #[doc = "           ensure that the window size is large enough to contain the entire source."]
-    #[doc = "           See ZSTD_c_windowLog."]
-    #[doc = "  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters."]
-    #[doc = "           It\'s a CPU consuming operation, with non-negligible impact on latency."]
-    #[doc = "           If there is a need to use the same prefix multiple times, consider loadDictionary instead."]
-    #[doc = "  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation."]
-    pub fn ZSTD_CCtx_refPrefix(
-        cctx: *mut ZSTD_CCtx,
-        prefix: *const ::std::os::raw::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary() :"]
-    #[doc = "  Create an internal DDict from dict buffer,"]
-    #[doc = "  to be used to decompress next frames."]
-    #[doc = "  The dictionary remains valid for all future frames, until explicitly invalidated."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,"]
-    #[doc = "            meaning \"return to no-dictionary mode\"."]
-    #[doc = "  Note 1 : Loading a dictionary involves building tables,"]
-    #[doc = "           which has a non-negligible impact on CPU usage and latency."]
-    #[doc = "           It\'s recommended to \"load once, use many times\", to amortize the cost"]
-    #[doc = "  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading."]
-    #[doc = "           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead."]
-    #[doc = "  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of"]
-    #[doc = "           how dictionary content is loaded and interpreted."]
-    pub fn ZSTD_DCtx_loadDictionary(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refDDict() :"]
-    #[doc = "  Reference a prepared dictionary, to be used to decompress next frames."]
-    #[doc = "  The dictionary remains active for decompression of future frames using same DCtx."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Currently, only one dictionary can be managed."]
-    #[doc = "           Referencing a new dictionary effectively \"discards\" any previous one."]
-    #[doc = "  Special: referencing a NULL DDict means \"return to no-dictionary mode\"."]
-    #[doc = "  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."]
-    pub fn ZSTD_DCtx_refDDict(
-        dctx: *mut ZSTD_DCtx,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refPrefix() :"]
-    #[doc = "  Reference a prefix (single-usage dictionary) to decompress next frame."]
-    #[doc = "  This is the reverse operation of ZSTD_CCtx_refPrefix(),"]
-    #[doc = "  and must use the same prefix as the one used during compression."]
-    #[doc = "  Prefix is **only used once**. Reference is discarded at end of frame."]
-    #[doc = "  End of frame is reached when ZSTD_decompressStream() returns 0."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    #[doc = "  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary"]
-    #[doc = "  Note 2 : Prefix buffer is referenced. It **must** outlive decompression."]
-    #[doc = "           Prefix buffer must remain unmodified up to the end of frame,"]
-    #[doc = "           reached when ZSTD_decompressStream() returns 0."]
-    #[doc = "  Note 3 : By default, the prefix is treated as raw content (ZSTD_dm_rawContent)."]
-    #[doc = "           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)"]
-    #[doc = "  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost."]
-    #[doc = "           A full dictionary is more costly, as it requires building tables."]
-    pub fn ZSTD_DCtx_refPrefix(
-        dctx: *mut ZSTD_DCtx,
-        prefix: *const ::std::os::raw::c_void,
-        prefixSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_sizeof_*() :"]
-    #[doc = "  These functions give the _current_ memory usage of selected object."]
-    #[doc = "  Note that object memory usage can evolve (increase or decrease) over time."]
-    pub fn ZSTD_sizeof_CCtx(cctx: *const ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DCtx(dctx: *const ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CStream(zcs: *const ZSTD_CStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DStream(zds: *const ZSTD_DStream) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_CDict(cdict: *const ZSTD_CDict) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_sizeof_DDict(ddict: *const ZSTD_DDict) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_CCtx_params_s {
-    _unused: [u8; 0],
-}
-pub type ZSTD_CCtx_params = ZSTD_CCtx_params_s;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_compressionParameters {
-    #[doc = "< largest match distance : larger == more compression, more memory needed during decompression"]
-    pub windowLog: ::std::os::raw::c_uint,
-    #[doc = "< fully searched segment : larger == more compression, slower, more memory (useless for fast)"]
-    pub chainLog: ::std::os::raw::c_uint,
-    #[doc = "< dispatch table : larger == faster, more memory"]
-    pub hashLog: ::std::os::raw::c_uint,
-    #[doc = "< nb of searches : larger == more compression, slower"]
-    pub searchLog: ::std::os::raw::c_uint,
-    #[doc = "< match length searched : larger == faster decompression, sometimes less compression"]
-    pub minMatch: ::std::os::raw::c_uint,
-    #[doc = "< acceptable match size for optimal parser (only) : larger == more compression, slower"]
-    pub targetLength: ::std::os::raw::c_uint,
-    #[doc = "< see ZSTD_strategy definition above"]
-    pub strategy: ZSTD_strategy,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_compressionParameters() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_compressionParameters>(),
-        28usize,
-        concat!("Size of: ", stringify!(ZSTD_compressionParameters))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_compressionParameters>(),
-        4usize,
-        concat!("Alignment of ", stringify!(ZSTD_compressionParameters))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).windowLog
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(windowLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).chainLog
-                as *const _ as usize
-        },
-        4usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(chainLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).hashLog
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(hashLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).searchLog
-                as *const _ as usize
-        },
-        12usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(searchLog)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).minMatch
-                as *const _ as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(minMatch)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>()))
-                .targetLength as *const _ as usize
-        },
-        20usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(targetLength)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_compressionParameters>())).strategy
-                as *const _ as usize
-        },
-        24usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_compressionParameters),
-            "::",
-            stringify!(strategy)
-        )
-    );
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_frameParameters {
-    #[doc = "< 1: content size will be in frame header (when known)"]
-    pub contentSizeFlag: ::std::os::raw::c_int,
-    #[doc = "< 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection"]
-    pub checksumFlag: ::std::os::raw::c_int,
-    #[doc = "< 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression)"]
-    pub noDictIDFlag: ::std::os::raw::c_int,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_frameParameters() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_frameParameters>(),
-        12usize,
-        concat!("Size of: ", stringify!(ZSTD_frameParameters))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_frameParameters>(),
-        4usize,
-        concat!("Alignment of ", stringify!(ZSTD_frameParameters))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameParameters>())).contentSizeFlag
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameParameters),
-            "::",
-            stringify!(contentSizeFlag)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameParameters>())).checksumFlag
-                as *const _ as usize
-        },
-        4usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameParameters),
-            "::",
-            stringify!(checksumFlag)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameParameters>())).noDictIDFlag
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameParameters),
-            "::",
-            stringify!(noDictIDFlag)
-        )
-    );
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_parameters {
-    pub cParams: ZSTD_compressionParameters,
-    pub fParams: ZSTD_frameParameters,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_parameters() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_parameters>(),
-        40usize,
-        concat!("Size of: ", stringify!(ZSTD_parameters))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_parameters>(),
-        4usize,
-        concat!("Alignment of ", stringify!(ZSTD_parameters))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_parameters>())).cParams as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_parameters),
-            "::",
-            stringify!(cParams)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_parameters>())).fParams as *const _
-                as usize
-        },
-        28usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_parameters),
-            "::",
-            stringify!(fParams)
-        )
-    );
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dictContentType_e {
-    ZSTD_dct_auto = 0,
-    ZSTD_dct_rawContent = 1,
-    ZSTD_dct_fullDict = 2,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dictLoadMethod_e {
-    #[doc = "< Copy dictionary content internally"]
-    ZSTD_dlm_byCopy = 0,
-    #[doc = "< Reference dictionary content -- the dictionary buffer must outlive its users."]
-    ZSTD_dlm_byRef = 1,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_format_e {
-    ZSTD_f_zstd1 = 0,
-    ZSTD_f_zstd1_magicless = 1,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_dictAttachPref_e {
-    ZSTD_dictDefaultAttach = 0,
-    ZSTD_dictForceAttach = 1,
-    ZSTD_dictForceCopy = 2,
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_literalCompressionMode_e {
-    #[doc = "< Automatically determine the compression mode based on the compression level."]
-    #[doc = "   Negative compression levels will be uncompressed, and positive compression"]
-    #[doc = "   levels will be compressed."]
-    ZSTD_lcm_auto = 0,
-    #[doc = "< Always attempt Huffman compression. Uncompressed literals will still be"]
-    #[doc = "   emitted if Huffman compression is not profitable."]
-    ZSTD_lcm_huffman = 1,
-    #[doc = "< Always emit uncompressed literals."]
-    ZSTD_lcm_uncompressed = 2,
-}
-extern "C" {
-    #[doc = " ZSTD_findDecompressedSize() :"]
-    #[doc = "  `src` should point to the start of a series of ZSTD encoded and/or skippable frames"]
-    #[doc = "  `srcSize` must be the _exact_ size of this series"]
-    #[doc = "       (i.e. there should be a frame boundary at `src + srcSize`)"]
-    #[doc = "  @return : - decompressed size of all data in all successive frames"]
-    #[doc = "            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN"]
-    #[doc = "            - if an error occurred: ZSTD_CONTENTSIZE_ERROR"]
-    #[doc = ""]
-    #[doc = "   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode."]
-    #[doc = "            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size."]
-    #[doc = "            In which case, it\'s necessary to use streaming mode to decompress data."]
-    #[doc = "   note 2 : decompressed size is always present when compression is done with ZSTD_compress()"]
-    #[doc = "   note 3 : decompressed size can be very large (64-bits value),"]
-    #[doc = "            potentially larger than what local system can handle as a single memory segment."]
-    #[doc = "            In which case, it\'s necessary to use streaming mode to decompress data."]
-    #[doc = "   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified."]
-    #[doc = "            Always ensure result fits within application\'s authorized limits."]
-    #[doc = "            Each application can set its own limits."]
-    #[doc = "   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to"]
-    #[doc = "            read each contained frame header.  This is fast as most of the data is skipped,"]
-    #[doc = "            however it does mean that all frame data must be present and valid."]
-    pub fn ZSTD_findDecompressedSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressBound() :"]
-    #[doc = "  `src` should point to the start of a series of ZSTD encoded and/or skippable frames"]
-    #[doc = "  `srcSize` must be the _exact_ size of this series"]
-    #[doc = "       (i.e. there should be a frame boundary at `src + srcSize`)"]
-    #[doc = "  @return : - upper-bound for the decompressed size of all data in all successive frames"]
-    #[doc = "            - if an error occured: ZSTD_CONTENTSIZE_ERROR"]
-    #[doc = ""]
-    #[doc = "  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame."]
-    #[doc = "  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`."]
-    #[doc = "            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value."]
-    #[doc = "  note 3  : when the decompressed size field isn\'t available, the upper-bound for that frame is calculated by:"]
-    #[doc = "              upper-bound = # blocks * min(128 KB, Window_Size)"]
-    pub fn ZSTD_decompressBound(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> ::std::os::raw::c_ulonglong;
-}
-extern "C" {
-    #[doc = " ZSTD_frameHeaderSize() :"]
-    #[doc = "  srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX."]
-    #[doc = " @return : size of the Frame Header,"]
-    #[doc = "           or an error code (if srcSize is too small)"]
-    pub fn ZSTD_frameHeaderSize(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_estimate*() :"]
-    #[doc = "  These functions make it possible to estimate memory usage"]
-    #[doc = "  of a future {D,C}Ctx, before its creation."]
-    #[doc = "  ZSTD_estimateCCtxSize() will provide a budget large enough for any compression level up to selected one."]
-    #[doc = "  It will also consider src size to be arbitrarily \"large\", which is worst case."]
-    #[doc = "  If srcSize is known to always be small, ZSTD_estimateCCtxSize_usingCParams() can provide a tighter estimation."]
-    #[doc = "  ZSTD_estimateCCtxSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel."]
-    #[doc = "  ZSTD_estimateCCtxSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1."]
-    #[doc = "  Note : CCtx size estimation is only correct for single-threaded compression."]
-    pub fn ZSTD_estimateCCtxSize(
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCCtxSize_usingCParams(
-        cParams: ZSTD_compressionParameters,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCCtxSize_usingCCtxParams(
-        params: *const ZSTD_CCtx_params,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDCtxSize() -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_estimateCStreamSize() :"]
-    #[doc = "  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one."]
-    #[doc = "  It will also consider src size to be arbitrarily \"large\", which is worst case."]
-    #[doc = "  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation."]
-    #[doc = "  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel."]
-    #[doc = "  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1."]
-    #[doc = "  Note : CStream size estimation is only correct for single-threaded compression."]
-    #[doc = "  ZSTD_DStream memory budget depends on window Size."]
-    #[doc = "  This information can be passed manually, using ZSTD_estimateDStreamSize,"]
-    #[doc = "  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();"]
-    #[doc = "  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),"]
-    #[doc = "         an internal ?Dict will be created, which additional size is not estimated here."]
-    #[doc = "         In this case, get total size by adding ZSTD_estimate?DictSize"]
-    pub fn ZSTD_estimateCStreamSize(
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCStreamSize_usingCParams(
-        cParams: ZSTD_compressionParameters,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCStreamSize_usingCCtxParams(
-        params: *const ZSTD_CCtx_params,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDStreamSize(windowSize: usize) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDStreamSize_fromFrame(
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_estimate?DictSize() :"]
-    #[doc = "  ZSTD_estimateCDictSize() will bet that src size is relatively \"small\", and content is copied, like ZSTD_createCDict()."]
-    #[doc = "  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced()."]
-    #[doc = "  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller."]
-    pub fn ZSTD_estimateCDictSize(
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateCDictSize_advanced(
-        dictSize: usize,
-        cParams: ZSTD_compressionParameters,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_estimateDDictSize(
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initStatic*() :"]
-    #[doc = "  Initialize an object using a pre-allocated fixed-size buffer."]
-    #[doc = "  workspace: The memory area to emplace the object into."]
-    #[doc = "             Provided pointer *must be 8-bytes aligned*."]
-    #[doc = "             Buffer must outlive object."]
-    #[doc = "  workspaceSize: Use ZSTD_estimate*Size() to determine"]
-    #[doc = "                 how large workspace must be to support target scenario."]
-    #[doc = " @return : pointer to object (same address as workspace, just different type),"]
-    #[doc = "           or NULL if error (size too small, incorrect alignment, etc.)"]
-    #[doc = "  Note : zstd will never resize nor malloc() when using a static buffer."]
-    #[doc = "         If the object requires more memory than available,"]
-    #[doc = "         zstd will just error out (typically ZSTD_error_memory_allocation)."]
-    #[doc = "  Note 2 : there is no corresponding \"free\" function."]
-    #[doc = "           Since workspace is allocated externally, it must be freed externally too."]
-    #[doc = "  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level"]
-    #[doc = "           into its associated cParams."]
-    #[doc = "  Limitation 1 : currently not compatible with internal dictionary creation, triggered by"]
-    #[doc = "                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict()."]
-    #[doc = "  Limitation 2 : static cctx currently not compatible with multi-threading."]
-    #[doc = "  Limitation 3 : static dctx is incompatible with legacy support."]
-    pub fn ZSTD_initStaticCCtx(
-        workspace: *mut ::std::os::raw::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_initStaticCStream(
-        workspace: *mut ::std::os::raw::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_initStaticDCtx(
-        workspace: *mut ::std::os::raw::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_initStaticDStream(
-        workspace: *mut ::std::os::raw::c_void,
-        workspaceSize: usize,
-    ) -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_initStaticCDict(
-        workspace: *mut ::std::os::raw::c_void,
-        workspaceSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-        cParams: ZSTD_compressionParameters,
-    ) -> *const ZSTD_CDict;
-}
-extern "C" {
-    pub fn ZSTD_initStaticDDict(
-        workspace: *mut ::std::os::raw::c_void,
-        workspaceSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> *const ZSTD_DDict;
-}
-#[doc = " Custom memory allocation :"]
-#[doc = "  These prototypes make it possible to pass your own allocation/free functions."]
-#[doc = "  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below."]
-#[doc = "  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones."]
-pub type ZSTD_allocFunction = ::core::option::Option<
-    unsafe extern "C" fn(
-        opaque: *mut ::std::os::raw::c_void,
-        size: usize,
-    ) -> *mut ::std::os::raw::c_void,
->;
-pub type ZSTD_freeFunction = ::core::option::Option<
-    unsafe extern "C" fn(
-        opaque: *mut ::std::os::raw::c_void,
-        address: *mut ::std::os::raw::c_void,
-    ),
->;
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_customMem {
-    pub customAlloc: ZSTD_allocFunction,
-    pub customFree: ZSTD_freeFunction,
-    pub opaque: *mut ::std::os::raw::c_void,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_customMem() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_customMem>(),
-        24usize,
-        concat!("Size of: ", stringify!(ZSTD_customMem))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_customMem>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_customMem))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_customMem>())).customAlloc as *const _
-                as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_customMem),
-            "::",
-            stringify!(customAlloc)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_customMem>())).customFree as *const _
-                as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_customMem),
-            "::",
-            stringify!(customFree)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_customMem>())).opaque as *const _
-                as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_customMem),
-            "::",
-            stringify!(opaque)
-        )
-    );
-}
-extern "C" {
-    #[link_name = "\u{1}ZSTD_defaultCMem"]
-    pub static ZSTD_defaultCMem: ZSTD_customMem;
-}
-extern "C" {
-    pub fn ZSTD_createCCtx_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_CCtx;
-}
-extern "C" {
-    pub fn ZSTD_createCStream_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_CStream;
-}
-extern "C" {
-    pub fn ZSTD_createDCtx_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_DCtx;
-}
-extern "C" {
-    pub fn ZSTD_createDStream_advanced(
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_DStream;
-}
-extern "C" {
-    pub fn ZSTD_createCDict_advanced(
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-        cParams: ZSTD_compressionParameters,
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    pub fn ZSTD_createDDict_advanced(
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-        customMem: ZSTD_customMem,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_createCDict_byReference() :"]
-    #[doc = "  Create a digested dictionary for compression"]
-    #[doc = "  Dictionary content is just referenced, not duplicated."]
-    #[doc = "  As a consequence, `dictBuffer` **must** outlive CDict,"]
-    #[doc = "  and its content must remain unmodified throughout the lifetime of CDict."]
-    pub fn ZSTD_createCDict_byReference(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> *mut ZSTD_CDict;
-}
-extern "C" {
-    #[doc = " ZSTD_getCParams() :"]
-    #[doc = " @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize."]
-    #[doc = " `estimatedSrcSize` value is optional, select 0 if not known"]
-    pub fn ZSTD_getCParams(
-        compressionLevel: ::std::os::raw::c_int,
-        estimatedSrcSize: ::std::os::raw::c_ulonglong,
-        dictSize: usize,
-    ) -> ZSTD_compressionParameters;
-}
-extern "C" {
-    #[doc = " ZSTD_getParams() :"]
-    #[doc = "  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`."]
-    #[doc = "  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0"]
-    pub fn ZSTD_getParams(
-        compressionLevel: ::std::os::raw::c_int,
-        estimatedSrcSize: ::std::os::raw::c_ulonglong,
-        dictSize: usize,
-    ) -> ZSTD_parameters;
-}
-extern "C" {
-    #[doc = " ZSTD_checkCParams() :"]
-    #[doc = "  Ensure param values remain within authorized range."]
-    #[doc = " @return 0 on success, or an error code (can be checked with ZSTD_isError())"]
-    pub fn ZSTD_checkCParams(params: ZSTD_compressionParameters) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_adjustCParams() :"]
-    #[doc = "  optimize params for a given `srcSize` and `dictSize`."]
-    #[doc = " `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = " `dictSize` must be `0` when there is no dictionary."]
-    #[doc = "  cPar can be invalid : all parameters will be clamped within valid range in the @return struct."]
-    #[doc = "  This function never fails (wide contract)"]
-    pub fn ZSTD_adjustCParams(
-        cPar: ZSTD_compressionParameters,
-        srcSize: ::std::os::raw::c_ulonglong,
-        dictSize: usize,
-    ) -> ZSTD_compressionParameters;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_advanced() :"]
-    #[doc = "  Same as ZSTD_compress_usingDict(), with fine-tune control over compression parameters (by structure)"]
-    pub fn ZSTD_compress_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compress_usingCDict_advanced() :"]
-    #[doc = "  Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters"]
-    pub fn ZSTD_compress_usingCDict_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-        fParams: ZSTD_frameParameters,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary_byReference() :"]
-    #[doc = "  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx."]
-    #[doc = "  It saves some memory, but also requires that `dict` outlives its usage within `cctx`"]
-    pub fn ZSTD_CCtx_loadDictionary_byReference(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_loadDictionary_advanced() :"]
-    #[doc = "  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over"]
-    #[doc = "  how to load the dictionary (by copy ? by reference ?)"]
-    #[doc = "  and how to interpret it (automatic ? force raw mode ? full mode only ?)"]
-    pub fn ZSTD_CCtx_loadDictionary_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_refPrefix_advanced() :"]
-    #[doc = "  Same as ZSTD_CCtx_refPrefix(), but gives finer control over"]
-    #[doc = "  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"]
-    pub fn ZSTD_CCtx_refPrefix_advanced(
-        cctx: *mut ZSTD_CCtx,
-        prefix: *const ::std::os::raw::c_void,
-        prefixSize: usize,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_getParameter() :"]
-    #[doc = "  Get the requested compression parameter value, selected by enum ZSTD_cParameter,"]
-    #[doc = "  and store it into int* value."]
-    #[doc = " @return : 0, or an error code (which can be tested with ZSTD_isError())."]
-    pub fn ZSTD_CCtx_getParameter(
-        cctx: *mut ZSTD_CCtx,
-        param: ZSTD_cParameter,
-        value: *mut ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_params :"]
-    #[doc = "  Quick howto :"]
-    #[doc = "  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure"]
-    #[doc = "  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into"]
-    #[doc = "                                     an existing ZSTD_CCtx_params structure."]
-    #[doc = "                                     This is similar to"]
-    #[doc = "                                     ZSTD_CCtx_setParameter()."]
-    #[doc = "  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to"]
-    #[doc = "                                    an existing CCtx."]
-    #[doc = "                                    These parameters will be applied to"]
-    #[doc = "                                    all subsequent frames."]
-    #[doc = "  - ZSTD_compressStream2() : Do compression using the CCtx."]
-    #[doc = "  - ZSTD_freeCCtxParams() : Free the memory."]
-    #[doc = ""]
-    #[doc = "  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()"]
-    #[doc = "  for static allocation of CCtx for single-threaded compression."]
-    pub fn ZSTD_createCCtxParams() -> *mut ZSTD_CCtx_params;
-}
-extern "C" {
-    pub fn ZSTD_freeCCtxParams(params: *mut ZSTD_CCtx_params) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_reset() :"]
-    #[doc = "  Reset params to default values."]
-    pub fn ZSTD_CCtxParams_reset(params: *mut ZSTD_CCtx_params) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_init() :"]
-    #[doc = "  Initializes the compression parameters of cctxParams according to"]
-    #[doc = "  compression level. All other parameters are reset to their default values."]
-    pub fn ZSTD_CCtxParams_init(
-        cctxParams: *mut ZSTD_CCtx_params,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_init_advanced() :"]
-    #[doc = "  Initializes the compression and frame parameters of cctxParams according to"]
-    #[doc = "  params. All other parameters are reset to their default values."]
-    pub fn ZSTD_CCtxParams_init_advanced(
-        cctxParams: *mut ZSTD_CCtx_params,
-        params: ZSTD_parameters,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_setParameter() :"]
-    #[doc = "  Similar to ZSTD_CCtx_setParameter."]
-    #[doc = "  Set one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = "  Parameters must be applied to a ZSTD_CCtx using ZSTD_CCtx_setParametersUsingCCtxParams()."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    pub fn ZSTD_CCtxParams_setParameter(
-        params: *mut ZSTD_CCtx_params,
-        param: ZSTD_cParameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtxParams_getParameter() :"]
-    #[doc = " Similar to ZSTD_CCtx_getParameter."]
-    #[doc = " Get the requested value of one compression parameter, selected by enum ZSTD_cParameter."]
-    #[doc = " @result : 0, or an error code (which can be tested with ZSTD_isError())."]
-    pub fn ZSTD_CCtxParams_getParameter(
-        params: *mut ZSTD_CCtx_params,
-        param: ZSTD_cParameter,
-        value: *mut ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_CCtx_setParametersUsingCCtxParams() :"]
-    #[doc = "  Apply a set of ZSTD_CCtx_params to the compression context."]
-    #[doc = "  This can be done even after compression is started,"]
-    #[doc = "    if nbWorkers==0, this will have no impact until a new compression is started."]
-    #[doc = "    if nbWorkers>=1, new parameters will be picked up at next job,"]
-    #[doc = "       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated)."]
-    pub fn ZSTD_CCtx_setParametersUsingCCtxParams(
-        cctx: *mut ZSTD_CCtx,
-        params: *const ZSTD_CCtx_params,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_compressStream2_simpleArgs() :"]
-    #[doc = "  Same as ZSTD_compressStream2(),"]
-    #[doc = "  but using only integral types as arguments."]
-    #[doc = "  This variant might be helpful for binders from dynamic languages"]
-    #[doc = "  which have troubles handling structures containing memory pointers."]
-    pub fn ZSTD_compressStream2_simpleArgs(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        dstPos: *mut usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        srcPos: *mut usize,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_isFrame() :"]
-    #[doc = "  Tells if the content of `buffer` starts with a valid Frame Identifier."]
-    #[doc = "  Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0."]
-    #[doc = "  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled."]
-    #[doc = "  Note 3 : Skippable Frame Identifiers are considered valid."]
-    pub fn ZSTD_isFrame(
-        buffer: *const ::std::os::raw::c_void,
-        size: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    #[doc = " ZSTD_createDDict_byReference() :"]
-    #[doc = "  Create a digested dictionary, ready to start decompression operation without startup delay."]
-    #[doc = "  Dictionary content is referenced, and therefore stays in dictBuffer."]
-    #[doc = "  It is important that dictBuffer outlives DDict,"]
-    #[doc = "  it must remain read accessible throughout the lifetime of DDict"]
-    pub fn ZSTD_createDDict_byReference(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> *mut ZSTD_DDict;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary_byReference() :"]
-    #[doc = "  Same as ZSTD_DCtx_loadDictionary(),"]
-    #[doc = "  but references `dict` content instead of copying it into `dctx`."]
-    #[doc = "  This saves memory if `dict` remains around.,"]
-    #[doc = "  However, it\'s imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression."]
-    pub fn ZSTD_DCtx_loadDictionary_byReference(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_loadDictionary_advanced() :"]
-    #[doc = "  Same as ZSTD_DCtx_loadDictionary(),"]
-    #[doc = "  but gives direct control over"]
-    #[doc = "  how to load the dictionary (by copy ? by reference ?)"]
-    #[doc = "  and how to interpret it (automatic ? force raw mode ? full mode only ?)."]
-    pub fn ZSTD_DCtx_loadDictionary_advanced(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictLoadMethod: ZSTD_dictLoadMethod_e,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_refPrefix_advanced() :"]
-    #[doc = "  Same as ZSTD_DCtx_refPrefix(), but gives finer control over"]
-    #[doc = "  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"]
-    pub fn ZSTD_DCtx_refPrefix_advanced(
-        dctx: *mut ZSTD_DCtx,
-        prefix: *const ::std::os::raw::c_void,
-        prefixSize: usize,
-        dictContentType: ZSTD_dictContentType_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setMaxWindowSize() :"]
-    #[doc = "  Refuses allocating internal buffers for frames requiring a window size larger than provided limit."]
-    #[doc = "  This protects a decoder context from reserving too much memory for itself (potential attack scenario)."]
-    #[doc = "  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode."]
-    #[doc = "  By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT)"]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setMaxWindowSize(
-        dctx: *mut ZSTD_DCtx,
-        maxWindowSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_DCtx_setFormat() :"]
-    #[doc = "  Instruct the decoder context about what kind of data to decode next."]
-    #[doc = "  This instruction is mandatory to decode data without a fully-formed header,"]
-    #[doc = "  such ZSTD_f_zstd1_magicless for example."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())."]
-    pub fn ZSTD_DCtx_setFormat(
-        dctx: *mut ZSTD_DCtx,
-        format: ZSTD_format_e,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_decompressStream_simpleArgs() :"]
-    #[doc = "  Same as ZSTD_decompressStream(),"]
-    #[doc = "  but using only integral types as arguments."]
-    #[doc = "  This can be helpful for binders from dynamic languages"]
-    #[doc = "  which have troubles handling structures containing memory pointers."]
-    pub fn ZSTD_decompressStream_simpleArgs(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        dstPos: *mut usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        srcPos: *mut usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_srcSize() :"]
-    #[doc = " This function is deprecated, and equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = ""]
-    #[doc = " pledgedSrcSize must be correct. If it is not known at init time, use"]
-    #[doc = " ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,"]
-    #[doc = " \"0\" also disables frame content size field. It may be enabled in the future."]
-    pub fn ZSTD_initCStream_srcSize(
-        zcs: *mut ZSTD_CStream,
-        compressionLevel: ::std::os::raw::c_int,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_usingDict() :"]
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);"]
-    #[doc = "     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);"]
-    #[doc = ""]
-    #[doc = " Creates of an internal CDict (incompatible with static CCtx), except if"]
-    #[doc = " dict == NULL or dictSize < 8, in which case no dict is used."]
-    #[doc = " Note: dict is loaded with ZSTD_dm_auto (treated as a full zstd dictionary if"]
-    #[doc = " it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy."]
-    pub fn ZSTD_initCStream_usingDict(
-        zcs: *mut ZSTD_CStream,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_advanced() :"]
-    #[doc = " This function is deprecated, and is approximately equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setZstdParams(zcs, params); // Set the zstd params and leave the rest as-is"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = "     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);"]
-    #[doc = ""]
-    #[doc = " pledgedSrcSize must be correct. If srcSize is not known at init time, use"]
-    #[doc = " value ZSTD_CONTENTSIZE_UNKNOWN. dict is loaded with ZSTD_dm_auto and ZSTD_dlm_byCopy."]
-    pub fn ZSTD_initCStream_advanced(
-        zcs: *mut ZSTD_CStream,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_usingCDict() :"]
-    #[doc = " This function is deprecated, and equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, cdict);"]
-    #[doc = ""]
-    #[doc = " note : cdict will just be referenced, and must outlive compression session"]
-    pub fn ZSTD_initCStream_usingCDict(
-        zcs: *mut ZSTD_CStream,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_initCStream_usingCDict_advanced() :"]
-    #[doc = " This function is deprecated, and is approximately equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setZstdFrameParams(zcs, fParams); // Set the zstd frame params and leave the rest as-is"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = "     ZSTD_CCtx_refCDict(zcs, cdict);"]
-    #[doc = ""]
-    #[doc = " same as ZSTD_initCStream_usingCDict(), with control over frame parameters."]
-    #[doc = " pledgedSrcSize must be correct. If srcSize is not known at init time, use"]
-    #[doc = " value ZSTD_CONTENTSIZE_UNKNOWN."]
-    pub fn ZSTD_initCStream_usingCDict_advanced(
-        zcs: *mut ZSTD_CStream,
-        cdict: *const ZSTD_CDict,
-        fParams: ZSTD_frameParameters,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_resetCStream() :"]
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = "     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"]
-    #[doc = ""]
-    #[doc = "  start a new frame, using same parameters from previous frame."]
-    #[doc = "  This is typically useful to skip dictionary loading stage, since it will re-use it in-place."]
-    #[doc = "  Note that zcs must be init at least once before using ZSTD_resetCStream()."]
-    #[doc = "  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN."]
-    #[doc = "  If pledgedSrcSize > 0, its value must be correct, as it will be written in header, and controlled at the end."]
-    #[doc = "  For the time being, pledgedSrcSize==0 is interpreted as \"srcSize unknown\" for compatibility with older programs,"]
-    #[doc = "  but it will change to mean \"empty\" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead."]
-    #[doc = " @return : 0, or an error code (which can be tested using ZSTD_isError())"]
-    pub fn ZSTD_resetCStream(
-        zcs: *mut ZSTD_CStream,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_frameProgression {
-    pub ingested: ::std::os::raw::c_ulonglong,
-    pub consumed: ::std::os::raw::c_ulonglong,
-    pub produced: ::std::os::raw::c_ulonglong,
-    pub flushed: ::std::os::raw::c_ulonglong,
-    pub currentJobID: ::std::os::raw::c_uint,
-    pub nbActiveWorkers: ::std::os::raw::c_uint,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_frameProgression() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_frameProgression>(),
-        40usize,
-        concat!("Size of: ", stringify!(ZSTD_frameProgression))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_frameProgression>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_frameProgression))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).ingested
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(ingested)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).consumed
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(consumed)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).produced
-                as *const _ as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(produced)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).flushed
-                as *const _ as usize
-        },
-        24usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(flushed)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).currentJobID
-                as *const _ as usize
-        },
-        32usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(currentJobID)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameProgression>())).nbActiveWorkers
-                as *const _ as usize
-        },
-        36usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameProgression),
-            "::",
-            stringify!(nbActiveWorkers)
-        )
-    );
-}
-extern "C" {
-    pub fn ZSTD_getFrameProgression(
-        cctx: *const ZSTD_CCtx,
-    ) -> ZSTD_frameProgression;
-}
-extern "C" {
-    #[doc = " ZSTD_toFlushNow() :"]
-    #[doc = "  Tell how many bytes are ready to be flushed immediately."]
-    #[doc = "  Useful for multithreading scenarios (nbWorkers >= 1)."]
-    #[doc = "  Probe the oldest active job, defined as oldest job not yet entirely flushed,"]
-    #[doc = "  and check its output buffer."]
-    #[doc = " @return : amount of data stored in oldest job and ready to be flushed immediately."]
-    #[doc = "  if @return == 0, it means either :"]
-    #[doc = "  + there is no active job (could be checked with ZSTD_frameProgression()), or"]
-    #[doc = "  + oldest job is still actively compressing data,"]
-    #[doc = "    but everything it has produced has also been flushed so far,"]
-    #[doc = "    therefore flush speed is limited by production speed of oldest job"]
-    #[doc = "    irrespective of the speed of concurrent (and newer) jobs."]
-    pub fn ZSTD_toFlushNow(cctx: *mut ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);"]
-    #[doc = ""]
-    #[doc = " note: no dictionary will be used if dict == NULL or dictSize < 8"]
-    pub fn ZSTD_initDStream_usingDict(
-        zds: *mut ZSTD_DStream,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);"]
-    #[doc = "     ZSTD_DCtx_refDDict(zds, ddict);"]
-    #[doc = ""]
-    #[doc = " note : ddict is referenced, it must outlive decompression session"]
-    pub fn ZSTD_initDStream_usingDDict(
-        zds: *mut ZSTD_DStream,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " This function is deprecated, and is equivalent to:"]
-    #[doc = ""]
-    #[doc = "     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);"]
-    #[doc = ""]
-    #[doc = " re-use decompression parameters from previous init; saves dictionary loading"]
-    pub fn ZSTD_resetDStream(zds: *mut ZSTD_DStream) -> usize;
-}
-extern "C" {
-    #[doc = "Buffer-less streaming compression (synchronous mode)"]
-    #[doc = ""]
-    #[doc = "A ZSTD_CCtx object is required to track streaming operations."]
-    #[doc = "Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource."]
-    #[doc = "ZSTD_CCtx object can be re-used multiple times within successive compression operations."]
-    #[doc = ""]
-    #[doc = "Start by initializing a context."]
-    #[doc = "Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,"]
-    #[doc = "or ZSTD_compressBegin_advanced(), for finer parameter control."]
-    #[doc = "It\'s also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()"]
-    #[doc = ""]
-    #[doc = "Then, consume your input using ZSTD_compressContinue()."]
-    #[doc = "There are some important considerations to keep in mind when using this advanced function :"]
-    #[doc = "- ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only."]
-    #[doc = "- Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks."]
-    #[doc = "- Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario."]
-    #[doc = "Worst case evaluation is provided by ZSTD_compressBound()."]
-    #[doc = "ZSTD_compressContinue() doesn\'t guarantee recover after a failed compression."]
-    #[doc = "- ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog)."]
-    #[doc = "It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)"]
-    #[doc = "- ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps."]
-    #[doc = "In which case, it will \"discard\" the relevant memory section from its history."]
-    #[doc = ""]
-    #[doc = "Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum."]
-    #[doc = "It\'s possible to use srcSize==0, in which case, it will write a final empty block to end the frame."]
-    #[doc = "Without last block mark, frames are considered unfinished (hence corrupted) by compliant decoders."]
-    #[doc = ""]
-    #[doc = "`ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again."]
-    pub fn ZSTD_compressBegin(
-        cctx: *mut ZSTD_CCtx,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_usingDict(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_advanced(
-        cctx: *mut ZSTD_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_usingCDict(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBegin_usingCDict_advanced(
-        cctx: *mut ZSTD_CCtx,
-        cdict: *const ZSTD_CDict,
-        fParams: ZSTD_frameParameters,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_copyCCtx(
-        cctx: *mut ZSTD_CCtx,
-        preparedCCtx: *const ZSTD_CCtx,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressContinue(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressEnd(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_frameType_e {
-    ZSTD_frame = 0,
-    ZSTD_skippableFrame = 1,
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTD_frameHeader {
-    pub frameContentSize: ::std::os::raw::c_ulonglong,
-    pub windowSize: ::std::os::raw::c_ulonglong,
-    pub blockSizeMax: ::std::os::raw::c_uint,
-    pub frameType: ZSTD_frameType_e,
-    pub headerSize: ::std::os::raw::c_uint,
-    pub dictID: ::std::os::raw::c_uint,
-    pub checksumFlag: ::std::os::raw::c_uint,
-}
-#[test]
-fn bindgen_test_layout_ZSTD_frameHeader() {
-    assert_eq!(
-        ::core::mem::size_of::<ZSTD_frameHeader>(),
-        40usize,
-        concat!("Size of: ", stringify!(ZSTD_frameHeader))
-    );
-    assert_eq!(
-        ::core::mem::align_of::<ZSTD_frameHeader>(),
-        8usize,
-        concat!("Alignment of ", stringify!(ZSTD_frameHeader))
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).frameContentSize
-                as *const _ as usize
-        },
-        0usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(frameContentSize)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).windowSize
-                as *const _ as usize
-        },
-        8usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(windowSize)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).blockSizeMax
-                as *const _ as usize
-        },
-        16usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(blockSizeMax)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).frameType as *const _
-                as usize
-        },
-        20usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(frameType)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).headerSize
-                as *const _ as usize
-        },
-        24usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(headerSize)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).dictID as *const _
-                as usize
-        },
-        28usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(dictID)
-        )
-    );
-    assert_eq!(
-        unsafe {
-            &(*(::core::ptr::null::<ZSTD_frameHeader>())).checksumFlag
-                as *const _ as usize
-        },
-        32usize,
-        concat!(
-            "Offset of field: ",
-            stringify!(ZSTD_frameHeader),
-            "::",
-            stringify!(checksumFlag)
-        )
-    );
-}
-extern "C" {
-    #[doc = " ZSTD_getFrameHeader() :"]
-    #[doc = "  decode Frame Header, or requires larger `srcSize`."]
-    #[doc = " @return : 0, `zfhPtr` is correctly filled,"]
-    #[doc = "          >0, `srcSize` is too small, value is wanted `srcSize` amount,"]
-    #[doc = "           or an error code, which can be tested using ZSTD_isError()"]
-    pub fn ZSTD_getFrameHeader(
-        zfhPtr: *mut ZSTD_frameHeader,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTD_getFrameHeader_advanced() :"]
-    #[doc = "  same as ZSTD_getFrameHeader(),"]
-    #[doc = "  with added capability to select a format (like ZSTD_f_zstd1_magicless)"]
-    pub fn ZSTD_getFrameHeader_advanced(
-        zfhPtr: *mut ZSTD_frameHeader,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        format: ZSTD_format_e,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decodingBufferSize_min(
-        windowSize: ::std::os::raw::c_ulonglong,
-        frameContentSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBegin(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBegin_usingDict(
-        dctx: *mut ZSTD_DCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBegin_usingDDict(
-        dctx: *mut ZSTD_DCtx,
-        ddict: *const ZSTD_DDict,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_nextSrcSizeToDecompress(dctx: *mut ZSTD_DCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressContinue(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_copyDCtx(dctx: *mut ZSTD_DCtx, preparedDCtx: *const ZSTD_DCtx);
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTD_nextInputType_e {
-    ZSTDnit_frameHeader = 0,
-    ZSTDnit_blockHeader = 1,
-    ZSTDnit_block = 2,
-    ZSTDnit_lastBlock = 3,
-    ZSTDnit_checksum = 4,
-    ZSTDnit_skippableFrame = 5,
-}
-extern "C" {
-    pub fn ZSTD_nextInputType(dctx: *mut ZSTD_DCtx) -> ZSTD_nextInputType_e;
-}
-extern "C" {
-    #[doc = "Block functions produce and decode raw zstd blocks, without frame metadata."]
-    #[doc = "Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes)."]
-    #[doc = "User will have to take in charge required information to regenerate data, such as compressed and content sizes."]
-    #[doc = ""]
-    #[doc = "A few rules to respect :"]
-    #[doc = "- Compressing and decompressing require a context structure"]
-    #[doc = "+ Use ZSTD_createCCtx() and ZSTD_createDCtx()"]
-    #[doc = "- It is necessary to init context before starting"]
-    #[doc = "+ compression : any ZSTD_compressBegin*() variant, including with dictionary"]
-    #[doc = "+ decompression : any ZSTD_decompressBegin*() variant, including with dictionary"]
-    #[doc = "+ copyCCtx() and copyDCtx() can be used too"]
-    #[doc = "- Block size is limited, it must be <= ZSTD_getBlockSize() <= ZSTD_BLOCKSIZE_MAX == 128 KB"]
-    #[doc = "+ If input is larger than a block size, it\'s necessary to split input data into multiple blocks"]
-    #[doc = "+ For inputs larger than a single block, really consider using regular ZSTD_compress() instead."]
-    #[doc = "Frame metadata is not that costly, and quickly becomes negligible as source size grows larger."]
-    #[doc = "- When a block is considered not compressible enough, ZSTD_compressBlock() result will be zero."]
-    #[doc = "In which case, nothing is produced into `dst` !"]
-    #[doc = "+ User must test for such outcome and deal directly with uncompressed data"]
-    #[doc = "+ ZSTD_decompressBlock() doesn\'t accept uncompressed data as input !!!"]
-    #[doc = "+ In case of multiple successive blocks, should some of them be uncompressed,"]
-    #[doc = "decoder must be informed of their existence in order to follow proper history."]
-    #[doc = "Use ZSTD_insertBlock() for such a case."]
-    pub fn ZSTD_getBlockSize(cctx: *const ZSTD_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_compressBlock(
-        cctx: *mut ZSTD_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_decompressBlock(
-        dctx: *mut ZSTD_DCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTD_insertBlock(
-        dctx: *mut ZSTD_DCtx,
-        blockStart: *const ::std::os::raw::c_void,
-        blockSize: usize,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZDICT_trainFromBuffer():"]
-    #[doc = "  Train a dictionary from an array of samples."]
-    #[doc = "  Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4,"]
-    #[doc = "  f=20, and accel=1."]
-    #[doc = "  Samples must be stored concatenated in a single flat buffer `samplesBuffer`,"]
-    #[doc = "  supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order."]
-    #[doc = "  The resulting dictionary will be saved into `dictBuffer`."]
-    #[doc = " @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)"]
-    #[doc = "          or an error code, which can be tested with ZDICT_isError()."]
-    #[doc = "  Note:  Dictionary training will fail if there are not enough samples to construct a"]
-    #[doc = "         dictionary, or if most of the samples are too small (< 8 bytes being the lower limit)."]
-    #[doc = "         If dictionary training fails, you should use zstd without a dictionary, as the dictionary"]
-    #[doc = "         would\'ve been ineffective anyways. If you believe your samples would benefit from a dictionary"]
-    #[doc = "         please open an issue with details, and we can look into it."]
-    #[doc = "  Note: ZDICT_trainFromBuffer()\'s memory usage is about 6 MB."]
-    #[doc = "  Tips: In general, a reasonable dictionary has a size of ~ 100 KB."]
-    #[doc = "        It\'s possible to select smaller or larger size, just by specifying `dictBufferCapacity`."]
-    #[doc = "        In general, it\'s recommended to provide a few thousands samples, though this can vary a lot."]
-    #[doc = "        It\'s recommended that total size of all samples be about ~x100 times the target size of dictionary."]
-    pub fn ZDICT_trainFromBuffer(
-        dictBuffer: *mut ::std::os::raw::c_void,
-        dictBufferCapacity: usize,
-        samplesBuffer: *const ::std::os::raw::c_void,
-        samplesSizes: *const usize,
-        nbSamples: ::std::os::raw::c_uint,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZDICT_getDictID(
-        dictBuffer: *const ::std::os::raw::c_void,
-        dictSize: usize,
-    ) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_isError(errorCode: usize) -> ::std::os::raw::c_uint;
-}
-extern "C" {
-    pub fn ZDICT_getErrorName(
-        errorCode: usize,
-    ) -> *const ::std::os::raw::c_char;
-}
-#[repr(C)]
-#[derive(Debug, Copy, Clone)]
-pub struct ZSTDMT_CCtx_s {
-    _unused: [u8; 0],
-}
-pub type ZSTDMT_CCtx = ZSTDMT_CCtx_s;
-extern "C" {
-    pub fn ZSTDMT_createCCtx(
-        nbWorkers: ::std::os::raw::c_uint,
-    ) -> *mut ZSTDMT_CCtx;
-}
-extern "C" {
-    pub fn ZSTDMT_createCCtx_advanced(
-        nbWorkers: ::std::os::raw::c_uint,
-        cMem: ZSTD_customMem,
-    ) -> *mut ZSTDMT_CCtx;
-}
-extern "C" {
-    pub fn ZSTDMT_freeCCtx(mtctx: *mut ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_sizeof_CCtx(mtctx: *mut ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_compressCCtx(
-        mtctx: *mut ZSTDMT_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_initCStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        compressionLevel: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_resetCStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_nextInputSizeHint(mtctx: *const ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_compressStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_flushStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_endStream(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_compress_advanced(
-        mtctx: *mut ZSTDMT_CCtx,
-        dst: *mut ::std::os::raw::c_void,
-        dstCapacity: usize,
-        src: *const ::std::os::raw::c_void,
-        srcSize: usize,
-        cdict: *const ZSTD_CDict,
-        params: ZSTD_parameters,
-        overlapLog: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_initCStream_advanced(
-        mtctx: *mut ZSTDMT_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        params: ZSTD_parameters,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_initCStream_usingCDict(
-        mtctx: *mut ZSTDMT_CCtx,
-        cdict: *const ZSTD_CDict,
-        fparams: ZSTD_frameParameters,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
-#[repr(u32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
-pub enum ZSTDMT_parameter {
-    ZSTDMT_p_jobSize = 0,
-    ZSTDMT_p_overlapLog = 1,
-    ZSTDMT_p_rsyncable = 2,
-}
-extern "C" {
-    pub fn ZSTDMT_setMTCtxParameter(
-        mtctx: *mut ZSTDMT_CCtx,
-        parameter: ZSTDMT_parameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    pub fn ZSTDMT_getMTCtxParameter(
-        mtctx: *mut ZSTDMT_CCtx,
-        parameter: ZSTDMT_parameter,
-        value: *mut ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_compressStream_generic() :"]
-    #[doc = "  Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream()"]
-    #[doc = "  depending on flush directive."]
-    #[doc = " @return : minimum amount of data still to be flushed"]
-    #[doc = "           0 if fully flushed"]
-    #[doc = "           or an error code"]
-    #[doc = "  note : needs to be init using any ZSTD_initCStream*() variant"]
-    pub fn ZSTDMT_compressStream_generic(
-        mtctx: *mut ZSTDMT_CCtx,
-        output: *mut ZSTD_outBuffer,
-        input: *mut ZSTD_inBuffer,
-        endOp: ZSTD_EndDirective,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_toFlushNow()"]
-    #[doc = "  Tell how many bytes are ready to be flushed immediately."]
-    #[doc = "  Probe the oldest active job (not yet entirely flushed) and check its output buffer."]
-    #[doc = "  If return 0, it means there is no active job,"]
-    #[doc = "  or, it means oldest job is still active, but everything produced has been flushed so far,"]
-    #[doc = "  therefore flushing is limited by speed of oldest job."]
-    pub fn ZSTDMT_toFlushNow(mtctx: *mut ZSTDMT_CCtx) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_CCtxParam_setMTCtxParameter()"]
-    #[doc = "  like ZSTDMT_setMTCtxParameter(), but into a ZSTD_CCtx_Params"]
-    pub fn ZSTDMT_CCtxParam_setMTCtxParameter(
-        params: *mut ZSTD_CCtx_params,
-        parameter: ZSTDMT_parameter,
-        value: ::std::os::raw::c_int,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_CCtxParam_setNbWorkers()"]
-    #[doc = "  Set nbWorkers, and clamp it."]
-    #[doc = "  Also reset jobSize and overlapLog"]
-    pub fn ZSTDMT_CCtxParam_setNbWorkers(
-        params: *mut ZSTD_CCtx_params,
-        nbWorkers: ::std::os::raw::c_uint,
-    ) -> usize;
-}
-extern "C" {
-    #[doc = " ZSTDMT_updateCParams_whileCompressing() :"]
-    #[doc = "  Updates only a selected set of compression parameters, to remain compatible with current frame."]
-    #[doc = "  New parameters will be applied to next compression job."]
-    pub fn ZSTDMT_updateCParams_whileCompressing(
-        mtctx: *mut ZSTDMT_CCtx,
-        cctxParams: *const ZSTD_CCtx_params,
-    );
-}
-extern "C" {
-    #[doc = " ZSTDMT_getFrameProgression():"]
-    #[doc = "  tells how much data has been consumed (input) and produced (output) for current frame."]
-    #[doc = "  able to count progression inside worker threads."]
-    pub fn ZSTDMT_getFrameProgression(
-        mtctx: *mut ZSTDMT_CCtx,
-    ) -> ZSTD_frameProgression;
-}
-extern "C" {
-    #[doc = " ZSTDMT_initCStream_internal() :"]
-    #[doc = "  Private use only. Init streaming operation."]
-    #[doc = "  expects params to be valid."]
-    #[doc = "  must receive dict, or cdict, or none, but not both."]
-    #[doc = "  @return : 0, or an error code"]
-    pub fn ZSTDMT_initCStream_internal(
-        zcs: *mut ZSTDMT_CCtx,
-        dict: *const ::std::os::raw::c_void,
-        dictSize: usize,
-        dictContentType: ZSTD_dictContentType_e,
-        cdict: *const ZSTD_CDict,
-        params: ZSTD_CCtx_params,
-        pledgedSrcSize: ::std::os::raw::c_ulonglong,
-    ) -> usize;
-}
Index: zstd-sys-1/src/lib.rs
===================================================================
--- zstd-sys-1.orig/src/lib.rs
+++ zstd-sys-1/src/lib.rs
@@ -9,37 +9,4 @@ extern crate libc;
 extern crate std;
 
 // If running bindgen, we'll end up with the correct bindings anyway.
-#[cfg(feature = "bindgen")]
 include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
-
-// The bindings used depend on a few feature flags.
-
-// No-std (libc-based)
-#[cfg(all(
-    not(feature = "std"),
-    not(feature = "experimental"),
-    not(feature = "bindgen")
-))]
-include!("bindings.rs");
-
-#[cfg(all(
-    not(feature = "std"),
-    feature = "experimental",
-    not(feature = "bindgen")
-))]
-include!("bindings_experimental.rs");
-
-// Std-based (no libc)
-#[cfg(all(
-    feature = "std",
-    not(feature = "experimental"),
-    not(feature = "bindgen")
-))]
-include!("bindings_std.rs");
-
-#[cfg(all(
-    feature = "std",
-    feature = "experimental",
-    not(feature = "bindgen")
-))]
-include!("bindings_std_experimental.rs");
Index: zstd-sys-1/update_bindings.sh
===================================================================
--- zstd-sys-1.orig/update_bindings.sh
+++ /dev/null
@@ -1,5 +0,0 @@
-#!/bin/sh
-bindgen zstd.h --ctypes-prefix ::libc --blacklist-type max_align_t --rustified-enum '.*' --use-core -o src/bindings.rs -- -Izstd/lib
-bindgen zstd.h --ctypes-prefix libc --blacklist-type max_align_t --rustified-enum '.*' --use-core -o src/bindings_experimental.rs -- -Izstd/lib -DZSTD_STATIC_LINKING_ONLY
-bindgen zstd.h --blacklist-type max_align_t --rustified-enum '.*' --use-core -o src/bindings_std.rs -- -Izstd/lib
-bindgen zstd.h --blacklist-type max_align_t --rustified-enum '.*' --use-core -o src/bindings_std_experimental.rs -- -Izstd/lib -DZSTD_STATIC_LINKING_ONLY
Index: zstd-sys-1/update_zstd.sh
===================================================================
--- zstd-sys-1.orig/update_zstd.sh
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/bin/bash
-cd zstd
-CURRENT=$(git describe --tags)
-git fetch
-TAG=$(git tag -l | grep '^v' | sort | tail -n 1)
-
-if [ $CURRENT != $TAG ]
-then
-    git checkout $TAG
-    cd ..
-    git add zstd
-    ./update_bindings.sh
-    git add src/bindings*.rs
-
-    # Note: You'll need a forked version of cargo-dump that supports metadata
-    # For instance https://github.com/gyscos/cargo-dump
-    METADATA="zstd.${TAG/v/}"
-    cargo bump patch --metadata $METADATA > /dev/null
-    git add Cargo.toml
-    cd ..
-    cargo bump patch --metadata $METADATA > /dev/null
-    git add Cargo.toml
-    cd ..
-    V=$(cargo bump patch --metadata $METADATA)
-    V=$(echo $V | cut -d' ' -f4 | cut -d'+' -f1)
-
-    git add Cargo.toml
-
-    git commit -m "Update zstd to $TAG"
-
-    # Publish?
-    read -p "Publish to crates.io? " -n 1 -r
-    echo $REPLY
-    if [[ $REPLY =~ ^[Yy]$ ]]
-    then
-        cd zstd-safe/zstd-sys
-        cargo publish
-        cd ..
-        cargo publish
-        cd ..
-        cargo publish
-        git tag $V
-    else
-        echo "Would have published $V"
-    fi
-
-else
-    echo "Already using zstd $TAG"
-fi
-
